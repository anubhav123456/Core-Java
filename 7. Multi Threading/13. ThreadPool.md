
---

## ğŸ“Œ Thread Pool 

---

## 1ï¸âƒ£ What happens to a thread after it finishes executing a task?

### âœ… Answer:

* After completing a task, a thread **does NOT terminate**.
* The thread **returns back to the thread pool** and waits for the next task.
* This **reuse of threads** avoids:

  * Costly thread creation
  * Thread destruction overhead
* Improves **performance and scalability** of applications.

ğŸ“Œ **Key Benefit:**
Thread reuse â†’ faster execution â†’ efficient resource utilization.

---

## 2ï¸âƒ£ How does `ThreadPoolExecutor` Queue Size affect behavior?

### ğŸ”¹ Role of Work Queue

* The **work queue** holds tasks **when all core threads are busy**.
* Tasks in the queue are **not yet assigned to any thread**.

### ğŸ”¹ Decision Flow (Very Important)

1. If **core threads are available** â†’ task goes to a core thread
2. If **core threads are busy** â†’ task goes to the queue
3. If **queue is full** â†’ new threads are created (up to `maxPoolSize`)
4. If **maxPoolSize reached & queue full** â†’ rejection policy is applied

---

## 3ï¸âƒ£ Complete Code Example

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolQueueExample {
    public static void main(String[] args) {

        // ThreadPoolExecutor configuration
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,                                  // corePoolSize
                4,                                  // maximumPoolSize
                10,                                 // keepAliveTime
                TimeUnit.SECONDS,                   // time unit
                new ArrayBlockingQueue<>(2),        // workQueue (size = 2)
                new ThreadPoolExecutor.AbortPolicy()// rejection policy
        );

        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println(
                        Thread.currentThread().getName() +
                        " is processing task " + taskId
                );
                try {
                    Thread.sleep(2000); // simulate task execution
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        executor.shutdown();
    }
}
```

---

## 4ï¸âƒ£ Small Queue vs Large Queue Behavior

---

### ğŸ”¹ Small Queue (Size = 2)

**Execution Flow:**

* First **2 tasks** â†’ assigned to core threads
* Next **2 tasks** â†’ placed in queue
* Queue becomes full â†’ **2 new threads created** (up to maxPoolSize = 4)
* If **all 4 threads busy & queue full** â†’ tasks rejected

**Outcome:**

* âœ… Faster execution
* âŒ Higher CPU & resource usage

ğŸ“Œ **Use Case:**
Low-latency systems where fast task execution is critical.

---

### ğŸ”¹ Large Queue (Size = 6)

**Execution Flow:**

* First **2 tasks** â†’ core threads
* Next **6 tasks** â†’ queued
* No new threads created until queue fills
* Threads beyond core are created **only when queue is full**

**Outcome:**

* âœ… Lower CPU usage
* âŒ Tasks may wait longer before execution

ğŸ“Œ **Use Case:**
Systems where throughput is more important than immediate response.

---

## ğŸ§  Interview Summary (One-liner)

> **Small Queue â†’ more threads â†’ faster but costly**
> **Large Queue â†’ fewer threads â†’ slower but resource-efficient**

---
