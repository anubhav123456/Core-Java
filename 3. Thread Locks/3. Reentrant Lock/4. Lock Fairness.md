
# ğŸ“Œ Lock Fairness

```java
ReentrantLock lock = new ReentrantLock(true); // FAIR LOCK
```


---

## âœ… Example: Fair ReentrantLock (Longest Waiting Thread First)

### ğŸ”¹ Key Idea

* `true` â†’ **fair lock**
* Threads acquire lock in **FIFO order**
* The thread that **waits longest** gets the lock next

---

## ğŸ”¹ Complete Code Example

### ğŸ“„ WorkerThread.java

```java
import java.util.concurrent.locks.ReentrantLock;

class WorkerThread extends Thread
{
    private ReentrantLock lock;

    public WorkerThread(String name, ReentrantLock lock)
    {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run()
    {
        System.out.println(getName() + " is waiting for the lock...");

        lock.lock();   // fair lock applied here
        try
        {
            System.out.println(getName() + " acquired the lock");

            Thread.sleep(1000); // simulate work
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println(getName() + " releasing the lock");
            lock.unlock();
        }
    }
}
```

---

### ğŸ“„ Main.java

```java
import java.util.concurrent.locks.ReentrantLock;

public class Main
{
    public static void main(String[] args) throws InterruptedException
    {
        ReentrantLock lock = new ReentrantLock(true); // FAIR LOCK

        WorkerThread t1 = new WorkerThread("Thread-1", lock);
        WorkerThread t2 = new WorkerThread("Thread-2", lock);
        WorkerThread t3 = new WorkerThread("Thread-3", lock);

        t1.start();
        Thread.sleep(100); // ensure t1 waits first

        t2.start();
        Thread.sleep(100); // ensure t2 waits next

        t3.start();
    }
}
```

---

## ğŸ”¹ Expected Output (Order Matters!)

```
Thread-1 is waiting for the lock...
Thread-1 acquired the lock
Thread-2 is waiting for the lock...
Thread-3 is waiting for the lock...
Thread-1 releasing the lock
Thread-2 acquired the lock
Thread-2 releasing the lock
Thread-3 acquired the lock
Thread-3 releasing the lock
```

---

## ğŸ§  Why This Output?

| Step | Explanation                             |
| ---- | --------------------------------------- |
| 1    | `Thread-1` starts first â†’ gets lock     |
| 2    | `Thread-2` starts â†’ waits               |
| 3    | `Thread-3` starts â†’ waits               |
| 4    | Lock released                           |
| 5    | **Thread-2 gets lock (waited longest)** |
| 6    | Thread-3 gets lock last                 |

âœ” FIFO order
âœ” No starvation
âœ” Fair scheduling

---

## ğŸ” What If `fair = false` ?

```java
ReentrantLock lock = new ReentrantLock(false);
```

âš  Possible output:

```
Thread-3 acquired the lock
Thread-2 acquired the lock
Thread-1 acquired the lock
```

* Order **not guaranteed**
* Random scheduling
* Possible starvation

---

## â­ Interview Explanation (One-Liner)

> *â€œWhen `ReentrantLock` is created with fairness set to true, it grants the lock to the thread that has been waiting the longest, following FIFO order, thus preventing starvation.â€*

---

## ğŸ”¥ Bonus Tip (Production Code)

Always use `try-finally`:

```java
lock.lock();
try {
   // critical section
} finally {
   lock.unlock();
}
```

---
