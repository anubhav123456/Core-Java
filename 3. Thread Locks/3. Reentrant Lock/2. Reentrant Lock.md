
---

## ðŸ” Locks in Java (Lock Interface & ReentrantLock)

### What is a Lock?

A **Lock** is a thread synchronization mechanism similar to `synchronized`, but it provides **more control and flexibility**.

Unlike `synchronized`, Lock is an **interface**, so we must use its implementations such as **ReentrantLock**.

---

## ðŸ” Lock vs `synchronized`

| Feature                          | synchronized | Lock (ReentrantLock)        |
| -------------------------------- | ------------ | --------------------------- |
| Timeout support                  | âŒ No         | âœ… Yes (`tryLock(timeout)`)  |
| Lock/unlock in different methods | âŒ No         | âœ… Yes                       |
| Interruptible lock               | âŒ No         | âœ… Yes (`lockInterruptibly`) |
| Fairness policy                  | âŒ No         | âœ… Yes                       |
| Explicit unlock required         | âŒ No         | âœ… Yes                       |

---

## ðŸ”„ Reentrant Lock

A **ReentrantLock** allows the **same thread** to acquire the same lock multiple times.

### How it works

* First `lock()` â†’ hold count = 1
* Re-enter `lock()` â†’ hold count increases
* Each `unlock()` â†’ hold count decreases
* Lock is released when hold count = 0

---

## âš–ï¸ Fairness in ReentrantLock

```java
Lock lock = new ReentrantLock(true); // fair lock
```

* Threads acquire lock **in order of waiting**
* Prevents starvation
* Slightly slower than unfair lock

---

## ðŸ”§ ReentrantLock Methods

| Method                | Description                       |
| --------------------- | --------------------------------- |
| `lock()`              | Blocks until lock acquired        |
| `unlock()`            | Releases lock                     |
| `tryLock()`           | Tries once, returns immediately   |
| `tryLock(time, unit)` | Waits for specified time          |
| `lockInterruptibly()` | Allows interruption while waiting |

---

## ðŸ¦ Bank Transfer Example using ReentrantLock

### Account Class

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BankTransfer {
    private int id;
    private double balance;
    private String accountName;
    private Lock lock = new ReentrantLock();

    public BankTransfer(int id, double balance, String accountName) {
        this.id = id;
        this.balance = balance;
        this.accountName = accountName;
    }

    public boolean withdraw(double amount) throws InterruptedException {
        if (lock.tryLock()) {
            Thread.sleep(100);
            balance -= amount;
            lock.unlock();
            return true;
        }
        return false;
    }

    public boolean deposit(double amount) throws InterruptedException {
        if (lock.tryLock()) {
            Thread.sleep(100);
            balance += amount;
            lock.unlock();
            return true;
        }
        return false;
    }

    public boolean transfer(BankTransfer to, double amount) throws InterruptedException {
        if (withdraw(amount)) {
            System.out.println("Withdrawing amount: " + amount + " from: " + accountName);
            if (to.deposit(amount)) {
                System.out.println("Depositing amount: " + amount + " to: " + to.accountName);
                return true;
            } else {
                System.out.println("Failed to acquire both locks: refunding " + amount + " to: " + accountName);
                while (!deposit(amount)) {
                    continue;
                }
            }
        }
        return false;
    }

    public double getBalance() {
        return balance;
    }

    public String getAccountName() {
        return accountName;
    }
}
```

---

## ðŸš€ Main Class (ExecutorService)

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        BankTransfer student = new BankTransfer(1, 50000, "Mike");
        BankTransfer university = new BankTransfer(2, 100000, "University");

        System.out.println("Starting balance of Mike is : " + student.getBalance());
        System.out.println("Starting balance of University is : " + university.getBalance());

        ExecutorService service = Executors.newFixedThreadPool(10);

        Runnable task = () -> {
            System.out.println(Thread.currentThread().getName() + " says :: Executing Transfer");
            try {
                while (!student.transfer(university, 1000)) {
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " says transfer is successful!!");
        };

        for (int i = 0; i < 20; i++) {
            service.submit(task);
        }

        service.shutdown();
        service.awaitTermination(1, TimeUnit.HOURS);

        System.out.println("Ending balance of Mike is : " + student.getBalance());
        System.out.println("Ending balance of University is : " + university.getBalance());
    }
}
```

---

## ðŸ“¤ Sample Output

```
Starting balance of Mike is : 50000.0
Starting balance of University is : 100000.0
pool-1-thread-3 says :: Executing Transfer
Withdrawing amount: 1000.0 from: Mike
Depositing amount: 1000.0 to: University
pool-1-thread-3 says transfer is successful!!
...
Ending balance of Mike is : 30000.0
Ending balance of University is : 120000.0
```

---

ðŸ“Œ **Interview Tip**: Always compare `synchronized` vs `Lock` with examples
