
---

# üîê Reentrant Lock in Java ‚Äî Complete Notes

## 1Ô∏è‚É£ What is a Reentrant Lock?

A **Reentrant Lock** is one of the main implementations of the `Lock` interface in Java (`java.util.concurrent.locks.ReentrantLock`).

üëâ **Reentrant** means:

> A thread that already holds a lock **can acquire it again without blocking itself**.

This prevents **self-deadlock**, which can occur with non-reentrant locks.

---

## 2Ô∏è‚É£ Why is it called *Reentrant*?

Because the **same thread can ‚Äúre-enter‚Äù the lock multiple times**.

Internally, the lock maintains:

* **Owner thread**
* **Hold count** (number of times the lock is acquired)

The lock is **fully released only when hold count becomes zero**.

---

## 3Ô∏è‚É£ How does Reentrant Lock work internally?

* When a thread acquires the lock:

  * Lock owner = current thread
  * Hold count = 1
* If the **same thread acquires the lock again**:

  * Hold count increments (2, 3, ...)
* Each `unlock()` call:

  * Decrements the hold count
* Lock is released **only when hold count reaches 0**

---

## 4Ô∏è‚É£ Why are Reentrant Locks needed?

### üî¥ Problem without Reentrancy (Deadlock)

Consider:

* `methodA()` acquires a lock
* `methodA()` calls `methodB()`
* `methodB()` tries to acquire the same lock

If the lock is **not reentrant**, the thread blocks itself ‚Üí **deadlock**

### ‚úÖ Solution

Use **ReentrantLock**, which allows the same thread to acquire the lock again.

---

## 5Ô∏è‚É£ Code Demonstration: Reentrant Lock

### ‚úÖ Example Code

```java
import java.util.concurrent.locks.ReentrantLock;

public class Main {

    private final ReentrantLock lock = new ReentrantLock();
    private int sharedData = 0;

    public void methodA() {
        lock.lock(); // 1st acquisition
        try {
            sharedData++;
            System.out.println("Method A: sharedData = " + sharedData);

            // Calling another method that also needs the same lock
            methodB();
        } finally {
            lock.unlock(); // hold count decreases
        }
    }

    public void methodB() {
        lock.lock(); // 2nd acquisition by same thread
        try {
            sharedData--;
            System.out.println("Method B: sharedData = " + sharedData);
        } finally {
            lock.unlock(); // hold count decreases again
        }
    }

    public static void main(String[] args) {
        Main example = new Main();

        // Create and start multiple threads
        for (int i = 0; i < 5; i++) {
            new Thread(example::methodA).start();
        }
    }
}
```

---

### üñ• Output

```
Method A: sharedData = 1
Method B: sharedData = 0
Method A: sharedData = 1
Method B: sharedData = 0
Method A: sharedData = 1
Method B: sharedData = 0
Method A: sharedData = 1
Method B: sharedData = 0
Method A: sharedData = 1
Method B: sharedData = 0
```

---

### üß† What‚Äôs happening here?

* Each thread:

  * Acquires the lock in `methodA()`
  * Re-acquires the same lock in `methodB()`
* Hold count becomes **2**
* Two `unlock()` calls reduce count to **0**
* Lock is released safely

---

## 6Ô∏è‚É£ Lock Fairness in ReentrantLock

### üîπ Fair Lock

```java
ReentrantLock lock = new ReentrantLock(true);
```

* Threads acquire the lock **in FIFO order**
* Longest waiting thread gets priority
* Slower, but avoids starvation

### üîπ Unfair Lock (Default)

```java
ReentrantLock lock = new ReentrantLock();
```

* No guaranteed order
* A thread can ‚Äúbarge‚Äù in
* Faster performance
* **Default behavior**

---

### ‚öñ Fair vs Unfair Summary

| Feature     | Fair Lock | Unfair Lock  |
| ----------- | --------- | ------------ |
| Ordering    | FIFO      | No guarantee |
| Starvation  | Prevented | Possible     |
| Performance | Slower    | Faster       |
| Default     | ‚ùå         | ‚úÖ            |

---

## 7Ô∏è‚É£ Important Methods of ReentrantLock

---

### üîπ `getHoldCount()`

```java
lock.getHoldCount();
```

üìå Returns:

* Number of times **current thread** has acquired the lock

---

### üîπ `tryLock()`

```java
if (lock.tryLock()) {
    try {
        // Critical section
    } finally {
        lock.unlock();
    }
}
```

üìå Key points:

* **Non-blocking**
* Returns `true` if lock acquired
* Returns `false` otherwise

---

### üîπ `tryLock(timeout, TimeUnit)`

```java
if (lock.tryLock(2, TimeUnit.SECONDS)) {
    try {
        // Critical section
    } finally {
        lock.unlock();
    }
}
```

üìå Behavior:

* Waits for the specified time
* Returns `false` if lock not acquired

---

### ‚ö† Problem with `tryLock()` and Fair Locks

Even if the lock is **fair**:

* `tryLock()` can bypass waiting threads

‚úÖ **Workaround**:

```java
lock.tryLock(0, TimeUnit.SECONDS);
```

This respects fairness.

---

### üîπ `isHeldByCurrentThread()`

```java
lock.isHeldByCurrentThread();
```

üìå Returns:

* `true` if current thread holds the lock

---

### üîπ `getQueueLength()`

```java
lock.getQueueLength();
```

üìå Returns:

* Approximate number of threads waiting

üõ† Mainly used for:

* Debugging
* Monitoring
* Profiling

---

### üîπ `newCondition()`

```java
Condition condition = lock.newCondition();
```

üìå Used for:

* Thread coordination (`await()`, `signal()`)
* Similar to `wait()` / `notify()` but **more powerful**

---

## 8Ô∏è‚É£ When to use ReentrantLock over `synchronized`?

| Feature             | synchronized | ReentrantLock |
| ------------------- | ------------ | ------------- |
| Reentrant           | ‚úÖ            | ‚úÖ             |
| tryLock             | ‚ùå            | ‚úÖ             |
| Timeout             | ‚ùå            | ‚úÖ             |
| Fairness            | ‚ùå            | ‚úÖ             |
| Multiple Conditions | ‚ùå            | ‚úÖ             |
| Explicit Unlock     | ‚ùå            | ‚úÖ             |

---

## 9Ô∏è‚É£ Key Takeaways ‚≠ê

* ReentrantLock allows **same thread to acquire lock multiple times**
* Prevents **self-deadlock**
* Maintains **hold count**
* Fair locks ensure order, unfair locks give better performance
* Offers advanced features not available in `synchronized`

---
