
---

# ðŸ“˜ Lock & Condition in Java â€” Notes

## 1ï¸âƒ£ Why Conditions Are Needed

* Locks help in **mutual exclusion** (only one thread accesses a resource).
* But threads also need **coordination**:

  * *When should a thread wait?*
  * *When should it continue?*
* **Conditions** provide a mechanism for **interaction between threads and locks**.

---

## 2ï¸âƒ£ Intuitive Analogy (Lock = Key + Door)

* Think of a **lock as a key**:

  * If you have the key â†’ the door unlocks â†’ you access the resource.
  * Only **one person (thread)** can enter at a time.
  * No tailgating allowed.
* If someone else holds the lock:

  * You cannot enter
  * You wait somewhere else

---

## 3ï¸âƒ£ What Is a Condition?

* A **Condition** is a **set of rules associated with a Lock**
* A **single lock can have multiple conditions**
* Condition = **Waiting room attached to the lock**

### Visualization

* Threads = people
* Lock = door + key
* Condition = waiting room
* Threads wait in the room until they are **signaled**

---

## 4ï¸âƒ£ How Threads Use Conditions

### Key Methods

| Method        | Purpose                                   |
| ------------- | ----------------------------------------- |
| `await()`     | Thread waits until condition is fulfilled |
| `signal()`    | Wake **one** waiting thread               |
| `signalAll()` | Wake **all** waiting threads              |

---

## 5ï¸âƒ£ Thread State Flow

1. Thread acquires lock
2. Condition not satisfied â†’ calls `await()`
3. Thread releases lock automatically
4. Thread enters **WAITING** state
5. Another thread fulfills condition
6. Calls `signal()` / `signalAll()`
7. Waiting thread(s) move to **RUNNABLE**
8. One thread re-acquires the lock and continues

---

## 6ï¸âƒ£ `signal()` vs `signalAll()`

### `signal()`

* Wakes **only one thread**
* Usually the **longest-waiting thread**
* Efficient, avoids unnecessary wakeups

### `signalAll()`

* Wakes **all waiting threads**
* JVM moves all from WAITING â†’ RUNNABLE
* Threads compete for lock again
* Used when:

  * Multiple threads may proceed
  * Complex condition logic

---

## 7ï¸âƒ£ Condition vs `wait()` / `notify()`

| Feature              | Condition                  | wait/notify               |
| -------------------- | -------------------------- | ------------------------- |
| Lock association     | Explicit (`ReentrantLock`) | Implicit (object monitor) |
| Multiple wait sets   | âœ… Yes                      | âŒ No                      |
| Fine-grained control | âœ… Yes                      | âŒ Limited                 |
| Modern usage         | âœ… Recommended              | âš  Legacy                  |

âž¡ **Condition = Advanced version of wait/notify**

---

## 8ï¸âƒ£ Producerâ€“Consumer Using Lock & Condition

### Shared Data

* Buffer (Queue)
* Max size = 5

---

### Locks & Conditions

```java
Lock lock = new ReentrantLock();

Condition bufferNotFull = lock.newCondition();
Condition bufferNotEmpty = lock.newCondition();
```

---

## 9ï¸âƒ£ Producer Logic

### Behavior

* Wait if buffer is full
* Add item to buffer
* Signal consumer

### Flow

1. `lock.lock()`
2. While buffer is full â†’ `bufferNotFull.await()`
3. Add item
4. `bufferNotEmpty.signal()`
5. `lock.unlock()` (in `finally`)

---

## ðŸ”Ÿ Consumer Logic

### Behavior

* Wait if buffer is empty
* Remove item
* Signal producer

### Flow

1. `lock.lock()`
2. While buffer empty â†’ `bufferNotEmpty.await()`
3. Remove item
4. `bufferNotFull.signal()`
5. `lock.unlock()` (in `finally`)

---

## 1ï¸âƒ£1ï¸âƒ£ Why Names Like `bufferNotEmpty`?

* Names are from the **signal perspective**
* Example:

  * Consumer **waits** on `bufferNotEmpty`
  * Producer **signals** `bufferNotEmpty` after producing
* Meaning:

  * â€œThis condition becomes true nowâ€

---

## 1ï¸âƒ£2ï¸âƒ£ Why Use `tryâ€“finally` with Locks?

```java
lock.lock();
try {
   // critical section
} finally {
   lock.unlock();
}
```

* Prevents **deadlock**
* Ensures lock is released even if exception occurs

---

## 1ï¸âƒ£3ï¸âƒ£ Thread Execution Demo

* Producer:

  * Produces every **1 second**
* Consumer:

  * Consumes every **2 seconds**
* Output shows:

  * Producer runs faster
  * Buffer temporarily fills
  * Conditions manage waiting & signaling

---

## 1ï¸âƒ£4ï¸âƒ£ Important Points to Remember

* Conditions:

  * Can only be created from **Lock implementations**
  * Example:

    * `ReentrantLock`
    * `ReadWriteLock`
* âŒ Not available with:

  * `synchronized`
  * Object-level intrinsic locks

---

## 1ï¸âƒ£5ï¸âƒ£ Key Takeaways

* Lock = mutual exclusion
* Condition = coordination
* Conditions enable:

  * Waiting for specific states
  * Fine-grained thread communication
* Prefer:

  * `Lock + Condition`
  * Over `synchronized + wait/notify`

---

### âœ… One-Line Summary

> **Conditions allow threads to wait and resume execution based on specific states while working with explicit locks in Java.**

---