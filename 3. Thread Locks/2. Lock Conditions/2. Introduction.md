
---

## 1Ô∏è‚É£ What is Lock & Condition in Java?

Java provides **explicit locking** via
`java.util.concurrent.locks.Lock` and `Condition` as a **more powerful alternative** to `synchronized`, `wait()`, and `notify()`.

### üîπ Lock

* `Lock` gives **manual control** over locking and unlocking.
* Implemented by `ReentrantLock`.

### üîπ Condition

* `Condition` is like **multiple wait-sets** per lock.
* Replaces `wait()`, `notify()`, `notifyAll()`.
* Allows **fine-grained thread coordination**.

### üîπ Why use Lock + Condition instead of synchronized?

| synchronized             | Lock + Condition          |
| ------------------------ | ------------------------- |
| Single implicit wait-set | Multiple condition queues |
| No fairness control      | Fair locks supported      |
| No try-lock              | tryLock(), timed lock     |
| Harder to debug          | More control              |

---

## 2Ô∏è‚É£ Important Methods

### Lock

```java
lock.lock();        // acquire lock
lock.unlock();      // release lock
lock.tryLock();     // try acquiring without blocking
```

### Condition

```java
condition.await();     // like wait()
condition.signal();    // like notify()
condition.signalAll(); // like notifyAll()
```

‚ö†Ô∏è **Rule:**
`await()` and `signal()` must be called **inside lock**.

---

## 3Ô∏è‚É£ Producer‚ÄìConsumer Problem (Using Lock & Condition)

### Problem

* Producer produces items into a buffer
* Consumer consumes items from buffer
* Buffer has **fixed capacity**
* Producer waits if buffer is full
* Consumer waits if buffer is empty

---

## 4Ô∏è‚É£ Producer‚ÄìConsumer Using Lock & Condition (Correct & Optimal)

### Shared Buffer Class

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BoundedBuffer {

    private final Queue<Integer> buffer = new LinkedList<>();
    private final int capacity;

    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    public BoundedBuffer(int capacity) {
        this.capacity = capacity;
    }

    public void produce(int item) throws InterruptedException {
        lock.lock();
        try {
            while (buffer.size() == capacity) {
                notFull.await(); // wait if buffer is full
            }

            buffer.add(item);
            System.out.println("Produced: " + item);

            notEmpty.signal(); // signal consumer
        } finally {
            lock.unlock();
        }
    }

    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (buffer.isEmpty()) {
                notEmpty.await(); // wait if buffer is empty
            }

            int item = buffer.poll();
            System.out.println("Consumed: " + item);

            notFull.signal(); // signal producer
            return item;
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 5Ô∏è‚É£ Producer Thread

```java
class Producer implements Runnable {

    private final BoundedBuffer buffer;

    public Producer(BoundedBuffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                buffer.produce(i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 6Ô∏è‚É£ Consumer Thread

```java
class Consumer implements Runnable {

    private final BoundedBuffer buffer;

    public Consumer(BoundedBuffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                buffer.consume();
                Thread.sleep(800);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 7Ô∏è‚É£ Main Class

```java
public class ProducerConsumerDemo {

    public static void main(String[] args) {
        BoundedBuffer buffer = new BoundedBuffer(5);

        Thread producer = new Thread(new Producer(buffer));
        Thread consumer = new Thread(new Consumer(buffer));

        producer.start();
        consumer.start();
    }
}
```

---

## 8Ô∏è‚É£ Why `while` instead of `if`?

**Very important interview point** üëá

```java
while (buffer.isEmpty()) {
    notEmpty.await();
}
```

* Protects against **spurious wakeups**
* Ensures condition is re-checked after waking

---

## 9Ô∏è‚É£ Key Interview Takeaways

‚úÖ `Lock` replaces `synchronized`
‚úÖ `Condition` replaces `wait/notify`
‚úÖ Multiple conditions = better control
‚úÖ Always unlock in `finally`
‚úÖ Use `while`, not `if`
‚úÖ Producer ‚Üí `notFull.await()`
‚úÖ Consumer ‚Üí `notEmpty.await()`

---
