
---

# üîê `lockInterruptibly()` Method ‚Äì ReentrantLock (Java)

## 1Ô∏è‚É£ Method Signature

```java
public void lockInterruptibly() throws InterruptedException
```

---

## 2Ô∏è‚É£ Key Points (Theory Notes)

* `lockInterruptibly()` is a **method of `Lock` interface**, implemented by `ReentrantLock`.
* It allows a thread to **acquire a lock unless it is interrupted**.
* **If the lock is free** ‚Üí thread acquires it immediately.
* **If the lock is not free** ‚Üí thread **waits** until:

  * it acquires the lock **OR**
  * it gets **interrupted**
* If the thread is **interrupted while waiting**, it:

  * **stops waiting**
  * **throws `InterruptedException`**
  * **does NOT acquire the lock**
* **Interrupt has no effect** if the thread is **not waiting for the lock**.

üëâ This is the **main difference** between:

* `lock()` ‚Üí ignores interrupts while waiting
* `lockInterruptibly()` ‚Üí responds to interrupts while waiting

---

## 3Ô∏è‚É£ Why `lockInterruptibly()` Is Important

* Prevents **deadlock-like waiting**
* Allows **graceful cancellation of threads**
* Very useful in:

  * task cancellation
  * responsive applications
  * thread pools

---

## 4Ô∏è‚É£ Example Code

### ‚úÖ Thread Class

```java
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread {
    ReentrantLock lock;

    public MyThread(String name, ReentrantLock lock) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            System.out.println(getName() + " is trying to acquire the lock");

            lock.lockInterruptibly(); // interruptible lock acquisition
            System.out.println(getName() + " has acquired the lock");

            for (int i = 0; i < 5; i++) {
                Thread.sleep(1000);
                System.out.println(getName() + " : " + i);
            }

            lock.unlock();
            System.out.println(getName() + " has released the lock");

        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

---

### ‚úÖ Main Class

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();

        MyThread thread1 = new MyThread("Thread 1", lock);
        MyThread thread2 = new MyThread("Thread 2", lock);

        thread1.start();
        thread2.start();

        Thread.sleep(8000);

        thread2.interrupt(); // interrupt thread2
    }
}
```

---

## 5Ô∏è‚É£ Program Output

```
Thread 1 is trying to acquire the lock
Thread 2 is trying to acquire the lock
Thread 1 has acquired the lock
Thread 1 : 0
Thread 1 : 1
Thread 1 : 2
Thread 1 : 3
Thread 1 : 4
Thread 2 has acquired the lock
Thread 1 has released the lock
Thread 2 : 0
Thread 2 : 1
Exception in thread "Thread 2" java.lang.RuntimeException:
java.lang.InterruptedException: sleep interrupted
```

---

## 6Ô∏è‚É£ Step-by-Step Execution Explanation

### üîπ Step 1: Thread Creation

* `Thread 1` and `Thread 2` share **same `ReentrantLock`**.

---

### üîπ Step 2: Lock Acquisition

* `Thread 1` acquires the lock first.
* `Thread 2` **waits** using `lockInterruptibly()`.

---

### üîπ Step 3: Thread 1 Executes

* Prints values `0 ‚Üí 4` with `sleep(1 second)`
* Releases the lock after loop

---

### üîπ Step 4: Thread 2 Acquires Lock

* After `Thread 1` releases the lock
* `Thread 2` successfully acquires it

---

### üîπ Step 5: Interrupt Happens

```java
thread2.interrupt();
```

* Interrupt occurs **while Thread 2 is sleeping**
* `Thread.sleep()` throws `InterruptedException`
* Exception is wrapped in `RuntimeException`
* Thread terminates abnormally

üëâ **Important:**
The interrupt **did NOT stop lock acquisition**, because:

* Thread 2 was **not waiting for the lock** at that moment
* It was already inside the critical section

---

## 7Ô∏è‚É£ Important Observations

| Scenario                         | Behavior                            |
| -------------------------------- | ----------------------------------- |
| Interrupt while waiting for lock | Lock acquisition stops              |
| Interrupt after acquiring lock   | Does NOT release lock automatically |
| `lock()` method                  | Ignores interrupt                   |
| `lockInterruptibly()`            | Responds to interrupt               |

---

## 8Ô∏è‚É£ Interview Difference: `lock()` vs `lockInterruptibly()`

| Feature           | lock()         | lockInterruptibly()    |
| ----------------- | -------------- | ---------------------- |
| Interrupt support | ‚ùå No           | ‚úÖ Yes                  |
| Throws exception  | ‚ùå              | ‚úÖ InterruptedException |
| Use case          | Simple locking | Cancelable tasks       |

---

## 9Ô∏è‚É£ Best Practice Tip ‚≠ê

Always use **`finally` block** for unlocking:

```java
lock.lockInterruptibly();
try {
    // critical section
} finally {
    lock.unlock();
}
```

Prevents **deadlocks** if exception occurs.

---

## üîö Summary

* `lockInterruptibly()` allows **interruptible waiting**
* Makes multithreaded apps **responsive & safe**
* Interrupt only matters **while waiting for lock**
* Interrupt during `sleep()` behaves differently

---
