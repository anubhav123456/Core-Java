
---

# ReentrantLock – `hasQueuedThreads()` & `getQueueLength()` Methods

## 1. Introduction to ReentrantLock Queue

* When multiple threads try to acquire a `ReentrantLock`, **only one thread gets the lock at a time**.
* Threads that **fail to acquire the lock immediately** are placed into an **internal waiting queue**.
* This queue is generally **FIFO (First Come First Serve)** when a **fair lock** is used.

```java
ReentrantLock lock = new ReentrantLock(true); // fair lock
```

---

## 2. `hasQueuedThreads()` Method

### Method Signature

```java
public final boolean hasQueuedThreads()
```

### Purpose

* Checks **whether any thread is waiting** to acquire the lock.

### Return Values

| Condition                   | Return  |
| --------------------------- | ------- |
| At least one thread waiting | `true`  |
| No thread waiting           | `false` |

### Key Point

* It **does NOT tell how many threads are waiting**, only whether the queue is empty or not.

---

## 3. `getQueueLength()` Method

### Method Signature

```java
public final int getQueueLength()
```

### Purpose

* Returns the **approximate number of threads waiting** for the lock.

### Important Notes

* The returned value is an **estimate**, not guaranteed exact.
* Used mainly for **monitoring and debugging**, not for synchronization logic.

---

## 4. Example Program Explanation

### Scenario

* 15 threads are created.
* All threads try to acquire the **same fair `ReentrantLock`**.
* Only **one thread executes at a time**.
* Remaining threads wait in the lock queue.
* The `main` thread periodically checks:

  * Are any threads waiting?
  * How many threads are waiting?

---

## 5. Code Example

### `MyThread.java`

```java
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread {
    private final ReentrantLock lock;

    public MyThread(String name, ReentrantLock lock) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        System.out.println(getName() + " is trying to acquire the lock");

        lock.lock();
        try {
            System.out.println(getName() + " has acquired the lock");

            for (int i = 0; i < 5; i++) {
                Thread.sleep(500);
                System.out.println(getName() + " : " + i);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
            System.out.println(getName() + " has released the lock");
        }
    }
}
```

---

### `Main.java`

```java
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        // Fair lock
        ReentrantLock lock = new ReentrantLock(true);

        MyThread[] threads = new MyThread[15];

        for (int i = 0; i < 15; i++) {
            threads[i] = new MyThread("Thread " + (i + 1), lock);
            threads[i].start();
        }

        // Monitor waiting threads
        while (true) {
            Thread.sleep(500);

            if (lock.hasQueuedThreads()) {
                System.out.println(
                    "No. of threads queued : " + lock.getQueueLength()
                );
            }

            boolean anyAlive = false;
            for (MyThread t : threads) {
                if (t.isAlive()) {
                    anyAlive = true;
                    break;
                }
            }

            if (!anyAlive) break;
        }

        System.out.println("All threads finished execution");
    }
}
```

---

## 6. Sample Output (Truncated)

```
Thread 7 is trying to acquire the lock
Thread 7 has acquired the lock
No. of threads queued : 14
Thread 7 : 0
No. of threads queued : 14
Thread 7 : 1
No. of threads queued : 14
Thread 7 : 2
Thread 7 : 3
Thread 7 : 4
Thread 7 has released the lock

Thread 2 has acquired the lock
No. of threads queued : 13
Thread 2 : 0
Thread 2 : 1
...
Thread 14 has acquired the lock
No. of threads queued : 0
Thread 14 : 4
Thread 14 has released the lock

All threads finished execution
```

---

## 7. Key Observations

* Only **one thread holds the lock at a time**.
* Other threads wait in the **lock queue**.
* `hasQueuedThreads()` prints output **only when someone is waiting**.
* Queue length **decreases gradually** as threads finish execution.
* **Fair lock ensures FIFO order**, but scheduling still depends on JVM & OS.

---

## 8. Interview Points ⭐

* `hasQueuedThreads()` → **boolean check**
* `getQueueLength()` → **approximate count**
* Queue is **FIFO only with fair lock**
* Methods are for **monitoring, not synchronization**
* `ReentrantLock` gives **more control than `synchronized`**

---
