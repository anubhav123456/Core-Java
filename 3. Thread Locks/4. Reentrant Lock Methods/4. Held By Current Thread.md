

---

## `ReentrantLock.isHeldByCurrentThread()`

### ğŸ“Œ Method Signature

```java
public boolean isHeldByCurrentThread()
```

---

### ğŸ“– Description

* Returns **`true`** if the **current thread** is holding this lock.
* Returns **`false`** if:

  * The lock is not held at all, or
  * The lock is held by **another thread**.

ğŸ‘‰ This method checks **ownership**, not just whether the lock is locked.

---

### âœ… Key Points

* Works only with **`ReentrantLock`**
* Useful for:

  * Debugging
  * Conditional unlocks
  * Avoiding `IllegalMonitorStateException`
* Thread-specific â†’ other threads calling this will get `false`

---

### ğŸ§  Example Code

```java
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        ReentrantLock lock = new ReentrantLock();

        lock.lock();
        System.out.println(
            Thread.currentThread().getName() +
            " is holding the lock : " +
            lock.isHeldByCurrentThread()
        );

        lock.unlock();
        System.out.println(
            Thread.currentThread().getName() +
            " is holding the lock : " +
            lock.isHeldByCurrentThread()
        );
    }
}
```

---

### ğŸ–¨ï¸ Output

```text
main is holding the lock : true
main is holding the lock : false
```

---

### ğŸ” Explanation

1. **Before `unlock()`**

   * `main` thread acquires the lock using `lock.lock()`
   * `isHeldByCurrentThread()` â†’ `true`

2. **After `unlock()`**

   * Lock is released
   * `isHeldByCurrentThread()` â†’ `false`

---

### âš ï¸ Important Note

```java
lock.unlock();
```

âŒ If called by a thread **not holding the lock**, it throws:

```text
IllegalMonitorStateException
```

ğŸ‘‰ Use `isHeldByCurrentThread()` to **safely check before unlocking**.

---

### ğŸ§© Typical Use Case

```java
if (lock.isHeldByCurrentThread()) {
    lock.unlock();
}
```

---

