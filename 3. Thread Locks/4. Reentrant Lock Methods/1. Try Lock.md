
---

# ğŸ” `tryLock()` Method of `ReentrantLock` â€“ Complete Notes

## ğŸ“Œ Overview

`tryLock()` is a method of the **`Lock` interface**, implemented by the **`ReentrantLock`** class (`java.util.concurrent.locks` package).

Unlike `lock()`, **`tryLock()` does not block indefinitely**.
A thread:

* Tries to acquire the lock
* **Gets it only if available**
* Otherwise **gives up immediately or after a fixed waiting time**

---

## 1ï¸âƒ£ `tryLock()` (No-Wait Version)

### ğŸ”¹ Method Signature

```java
public boolean tryLock()
```

### ğŸ”¹ Key Points

* Present in **Lock interface**
* Implemented by **ReentrantLock**
* **Non-blocking**
* Tries **only once**
* Returns:

  * `true` â†’ lock acquired
  * `false` â†’ lock not available, thread gives up
* Can be called multiple times, but **each call tries only once**

---

### ğŸ”¹ Example Code

```java
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread {
    ReentrantLock lock;

    public MyThread(String name, ReentrantLock lock) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        if (lock.tryLock()) {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(getName() + " : " + i);
            }
            lock.unlock();
        } else {
            System.out.println(getName() + " can not get the lock");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();

        MyThread thread1 = new MyThread("Thread 1", lock);
        MyThread thread2 = new MyThread("Thread 2", lock);

        thread1.start();
        thread2.start();
    }
}
```

---

### ğŸ”¹ Output (One Possible Execution)

```
Thread 2 can not get the lock
Thread 1 : 0
Thread 1 : 1
Thread 1 : 2
Thread 1 : 3
Thread 1 : 4
```

### ğŸ”¹ Explanation

* Both threads share **same lock**
* One thread acquires lock first
* Second thread calls `tryLock()` **once**
* Since lock is unavailable â†’ returns `false`
* Second thread **never retries**, even after unlock

---

## 2ï¸âƒ£ `tryLock(long time, TimeUnit unit)` (Timed Version)

### ğŸ”¹ Method Signature

```java
public boolean tryLock(long time, TimeUnit unit)
        throws InterruptedException
```

### ğŸ”¹ Key Points

* Thread:

  * Gets lock immediately if available
  * Otherwise waits **up to given time**
* If still unavailable â†’ **gives up**
* Throws **checked exception** `InterruptedException`
* More flexible than plain `tryLock()`

---

## â± `TimeUnit` Enum

Located in `java.util.concurrent`

```java
public enum TimeUnit {
    NANOSECONDS,
    MICROSECONDS,
    MILLISECONDS,
    SECONDS,
    MINUTES,
    HOURS,
    DAYS
}
```

---

### ğŸ”¹ Example with Waiting Time

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread {
    ReentrantLock lock;

    public MyThread(String name, ReentrantLock lock) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            if (lock.tryLock(10000, TimeUnit.MILLISECONDS)) {
                for (int i = 0; i < 5; i++) {
                    Thread.sleep(500);
                    System.out.println(getName() + " : " + i);
                }
                lock.unlock();
            } else {
                System.out.println(getName() + " can not get the lock");
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();

        MyThread thread1 = new MyThread("Thread 1", lock);
        MyThread thread2 = new MyThread("Thread 2", lock);

        thread1.start();
        thread2.start();
    }
}
```

---

### ğŸ”¹ Output

```
Thread 1 : 0
Thread 1 : 1
Thread 1 : 2
Thread 1 : 3
Thread 1 : 4
Thread 2 : 0
Thread 2 : 1
Thread 2 : 2
Thread 2 : 3
Thread 2 : 4
```

### ğŸ”¹ Explanation

* Thread 1 acquires lock first
* Thread 2 waits **up to 10 seconds**
* Thread 1 releases lock before timeout
* Thread 2 successfully acquires lock

---

## 3ï¸âƒ£ Using Very Small Timeout (Nanoseconds)

```java
if (lock.tryLock(10000, TimeUnit.NANOSECONDS)) {
    // critical section
}
```

### ğŸ”¹ Result

* 10,000 nanoseconds = **very small time**
* If lock not released quickly â†’ second thread fails

#### Output Example

```
Thread 1 can not get the lock
```

---

## 4ï¸âƒ£ Re-trying Using `while(true)` Loop

### ğŸ”¹ Code

```java
try {
    while (true) {
        System.out.println(getName() + " is trying to acquire the lock");

        if (lock.tryLock(1, TimeUnit.NANOSECONDS)) {
            for (int i = 0; i < 5; i++) {
                Thread.sleep(500);
                System.out.println(getName() + " : " + i);
            }
            lock.unlock();
            break; // exit loop after success
        } else {
            System.out.println(getName() + " can not get the lock");
        }
    }
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}
```

---

### ğŸ”¹ Explanation

* Thread keeps retrying until lock is acquired
* Small timeout avoids blocking
* `break` ensures loop stops after success
* Demonstrates **manual retry mechanism**

---

## ğŸ†š Comparison Summary

| Method                | Blocking   | Wait Time | Retry     |
| --------------------- | ---------- | --------- | --------- |
| `lock()`              | Yes        | Infinite  | Automatic |
| `tryLock()`           | No         | 0         | No        |
| `tryLock(time, unit)` | Limited    | Fixed     | No        |
| `tryLock()` + loop    | Controlled | Custom    | Yes       |

---

## âœ… Key Interview Points

* `tryLock()` avoids deadlock
* Best when thread **must not wait**
* Timed `tryLock()` gives **controlled waiting**
* Requires manual retry logic if needed
* Preferred over `synchronized` for flexibility

---
