
---

# 1. What is `StampedLock`?

`StampedLock` (Java 8+) is a **high-performance lock** designed for scenarios with:

* **Many readers**
* **Few writers**
* Heavy contention where **blocking readers is expensive**

Instead of returning a `Lock` object, it returns a **stamp (long value)** that represents the lock state.

```java
StampedLock lock = new StampedLock();
```

---

# 2. Three Modes of `StampedLock` (with code)

`StampedLock` supports **three modes**:

| Mode                | Blocking? | Purpose                          |
| ------------------- | --------- | -------------------------------- |
| **Write Lock**      | Yes       | Exclusive write                  |
| **Read Lock**       | Yes       | Shared read                      |
| **Optimistic Read** | No        | Ultra-fast read without blocking |

---

## 2.1 Write Lock (Exclusive)

Only **one writer** allowed. Blocks all readers and writers.

```java
StampedLock lock = new StampedLock();
int balance = 0;

public void deposit(int amount) {
    long stamp = lock.writeLock();   // blocking
    try {
        balance += amount;
    } finally {
        lock.unlockWrite(stamp);
    }
}
```

### Key Points

* Similar to `writeLock()` of `ReentrantReadWriteLock`
* Exclusive access
* **Heavy operation**

---

## 2.2 Read Lock (Shared)

Multiple readers allowed **if no writer is present**.

```java
public int getBalance() {
    long stamp = lock.readLock();   // blocking
    try {
        return balance;
    } finally {
        lock.unlockRead(stamp);
    }
}
```

### Key Points

* Same behavior as `readLock()` of `ReentrantReadWriteLock`
* Readers block if writer is active

---

## 2.3 Optimistic Read (Non-blocking ⭐)

This is the **killer feature** of `StampedLock`.

### How it works

1. Read data **without locking**
2. Validate if a write happened during the read
3. If validation fails → fallback to read lock

```java
public int getBalanceOptimistic() {
    long stamp = lock.tryOptimisticRead(); // non-blocking
    int currentBalance = balance;          // read

    if (!lock.validate(stamp)) {
        // A write happened → fallback
        stamp = lock.readLock();
        try {
            currentBalance = balance;
        } finally {
            lock.unlockRead(stamp);
        }
    }
    return currentBalance;
}
```

### Why this is fast?

* **No blocking**
* No context switch
* Perfect for **read-heavy systems**

---

# 3. Optimistic Read vs Optimistic Write

### 3.1 Optimistic Read ✔ (Supported)

* `StampedLock` **supports optimistic reads**
* Writers are allowed during optimistic read
* Validation detects interference

---

### 3.2 Optimistic Write ❌ (Not Supported)

There is **NO optimistic write** in `StampedLock`.

### Why?

* Writes modify shared state
* Unsafe to allow concurrent writes optimistically
* Would break consistency

So:

```text
Optimistic Read → YES
Optimistic Write → NO
```

---

# 4. Why `StampedLock` over `ReentrantReadWriteLock`?

This is **interview gold**.

---

## 4.1 Major Differences

| Feature                  | ReentrantReadWriteLock | StampedLock |
| ------------------------ | ---------------------- | ----------- |
| Optimistic Read          | ❌                      | ✅           |
| Performance (read-heavy) | Medium                 | **High**    |
| Reentrancy               | ✅                      | ❌           |
| Lock object              | Lock                   | long stamp  |
| Lock upgrade             | Manual & risky         | Safer       |
| Fairness                 | Configurable           | ❌           |
| Condition support        | ✅                      | ❌           |

---

## 4.2 Example: Read-Heavy System (WHY StampedLock wins)

### With `ReentrantReadWriteLock`

```java
readLock.lock();
try {
    return balance;
} finally {
    readLock.unlock();
}
```

❌ Reader blocks if writer exists

---

### With `StampedLock`

```java
long stamp = lock.tryOptimisticRead();
int val = balance;
if (!lock.validate(stamp)) {
    stamp = lock.readLock();
    try {
        val = balance;
    } finally {
        lock.unlockRead(stamp);
    }
}
```

✅ Readers **don’t block writers**
✅ Massive throughput improvement

---

# 5. Lock Conversion (StampedLock Advantage)

`StampedLock` supports **lock conversion**:

### Read → Write (if no conflict)

```java
long stamp = lock.readLock();
try {
    if (balance < 100) {
        long ws = lock.tryConvertToWriteLock(stamp);
        if (ws != 0) {
            stamp = ws;
            balance += 50;
        }
    }
} finally {
    lock.unlock(stamp);
}
```

This is **hard and unsafe** in `ReentrantReadWriteLock`.

---

# 6. What `ReentrantReadWriteLock` features does `StampedLock` cover?

### Covered by `StampedLock`

* ✅ Read lock
* ✅ Write lock
* ✅ High concurrency reads
* ✅ Lock upgrade/downgrade (better)

### NOT covered

* ❌ Reentrancy
* ❌ Fairness
* ❌ Conditions
* ❌ Interruptible lock acquisition

---

# 7. When NOT to use `StampedLock`

❌ If you need:

* Reentrant behavior
* Thread interruption
* Fair scheduling
* Condition variables

Use `ReentrantReadWriteLock` instead.

---

# 8. Interview Summary (One-liner answers)

> **Why StampedLock?**
> Because it provides **optimistic reads**, reducing contention and improving performance in read-heavy systems.

> **Is StampedLock reentrant?**
> No.

> **Optimistic write supported?**
> No, only optimistic read.

---

