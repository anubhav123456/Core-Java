
---

# ğŸ“Œ StampedLock in Java (Java 8 & Higher)

## ğŸ”¹ What is StampedLock?

`StampedLock` is an advanced **readerâ€“writer lock** introduced in **Java 8**.

### Why StampedLock?

* Faster than `ReentrantReadWriteLock`
* Best when **readers >> writers**
* Avoids reader starvation
* Supports **optimistic reads**
* Allows **lock conversion (read â†’ write)**

ğŸ“Œ **Not Reentrant**
A thread **cannot re-acquire** a lock it already holds.

---

## ğŸ”¹ When to Use StampedLock?

âœ” High read concurrency
âœ” Rare writes
âœ” Need optimistic reads
âœ” Need lock upgrade/downgrade

âŒ When you need:

* Reentrancy
* Conditions (`Condition` interface)

---

## ğŸ”¹ Locking Modes in StampedLock

### 1ï¸âƒ£ Write Lock

```java
long writeLock()
long tryWriteLock()
long tryWriteLock(long time, TimeUnit unit)
```

* Exclusive access
* Blocks readers and writers

---

### 2ï¸âƒ£ Read Lock

```java
long readLock()
```

* Multiple threads allowed
* Blocks writers

---

### 3ï¸âƒ£ Optimistic Read

```java
long tryOptimisticRead()
boolean validate(long stamp)
```

* **No locking**
* Must validate later
* Fastest read mode

---

## ğŸ”¹ Stamp Value

* Returned as `long`
* Contains:

  * Lock mode (read/write/optimistic)
  * Version
* Required to unlock or convert lock

---

# ğŸ§© CODE EXAMPLES

---

## âœ… Example 1: Write Lock (Exclusive Access)

### Code

```java
import java.util.concurrent.locks.*;

class CreateThread {
    public static void main(String[] args) {
        StampedLock lock = new StampedLock();

        MyThread[] t = new MyThread[5];

        for (int i = 0; i < 5; i++) {
            t[i] = new MyThread("t" + i, lock);
        }

        for (int i = 0; i < 5; i++) {
            t[i].start();
        }
    }
}
```

```java
import java.util.concurrent.locks.*;

public class MyThread extends Thread {
    StampedLock lock;

    public MyThread(String name, StampedLock lock) {
        super(name);
        this.lock = lock;
    }

    public void run() {
        long stamp = lock.writeLock();
        System.out.println(getName() + " Got the writeLock");

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {}

        lock.unlockWrite(stamp);
        System.out.println(getName() + " Finished");
    }
}
```

### ğŸ” Output (Sequential Execution)

```
t0 Got the writeLock
t0 Finished
t1 Got the writeLock
t1 Finished
t2 Got the writeLock
t2 Finished
t3 Got the writeLock
t3 Finished
t4 Got the writeLock
t4 Finished
```

ğŸ“Œ Only **one thread at a time** enters the critical section.

---

## âœ… Example 2: Read Lock â†’ Convert to Write Lock

### Code

```java
import java.util.concurrent.locks.*;

public class MyThread extends Thread {
    StampedLock lock;

    public MyThread(String name, StampedLock lock) {
        super(name);
        this.lock = lock;
    }

    public void run() {
        long stamp = lock.readLock();
        System.out.println(getName() + " Got the readLock");

        long stamp1 = lock.tryConvertToWriteLock(stamp);
        if (stamp1 != 0) {
            stamp = stamp1;
            System.out.println(getName() + " Converted to writeLock");
            lock.unlockWrite(stamp);
        } else {
            lock.unlockRead(stamp);
        }

        System.out.println(getName() + " Finished");
    }
}
```

### ğŸ” Output (Possible)

```
t0 Got the readLock
t1 Got the readLock
t2 Got the readLock
t0 Converted to writeLock
t0 Finished
t1 Finished
t2 Finished
```

ğŸ“Œ **Key Advantage over ReentrantReadWriteLock**
âœ” Allows **read â†’ write upgrade** without releasing lock first

---

## âœ… Example 3: Optimistic Read

### Code

```java
import java.util.concurrent.locks.*;

public class MyThread extends Thread {
    StampedLock lock;

    public MyThread(String name, StampedLock lock) {
        super(name);
        this.lock = lock;
    }

    public void run() {
        long stamp = lock.tryOptimisticRead();
        System.out.println(getName() + " Optimistic Read Stamp is " + stamp);

        // simulate work
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {}

        if (!lock.validate(stamp)) {
            stamp = lock.readLock();
            System.out.println(getName() + " Changed Stamp is " + stamp);
            lock.unlockRead(stamp);
        }
    }
}
```

### ğŸ” Output (Possible)

```
t0 Optimistic Read Stamp is 256
t1 Optimistic Read Stamp is 256
t0 Changed Stamp is 512
```

ğŸ“Œ If a write occurs â†’ optimistic read becomes invalid

---

# âš ï¸ Important Caveats

## âŒ Not Reentrant

```java
// DEADLOCK scenario
methodA() {
    lock.readLock();
    methodB(); // also tries to acquire lock
}
```

âœ” Unlike `ReentrantLock`, **same thread cannot re-acquire**

---

## âŒ No Conditions Support

* Cannot use `Condition`
* Use `ReentrantLock` when `wait/notify`-style signaling is needed

---

# ğŸ” Comparison Summary

| Feature          | ReentrantLock | ReentrantReadWriteLock | StampedLock |
| ---------------- | ------------- | ---------------------- | ----------- |
| Reentrant        | âœ…             | âœ…                      | âŒ           |
| Read concurrency | âŒ             | âœ…                      | âœ…           |
| Optimistic Read  | âŒ             | âŒ                      | âœ…           |
| Lock conversion  | âŒ             | âŒ                      | âœ…           |
| Conditions       | âœ…             | âœ…                      | âŒ           |
| Performance      | Medium        | Good                   | ğŸš€ Best     |

---


# ğŸ§¾ Final Takeaways

âœ” Use **StampedLock** when:

* Read-heavy workloads
* Need fast optimistic reads
* Need lock upgrades

âŒ Avoid when:

* Reentrancy required
* Conditions required

---
