
---

# Semaphore in Java (java.util.concurrent)

## 1. What is a Semaphore?

A **Semaphore** is a synchronization aid that controls access to a shared resource by maintaining a **fixed number of permits**.

* Threads must **acquire()** a permit before entering the critical section.
* After finishing work, threads must **release()** the permit.
* If no permit is available, the thread **waits (blocks)** until one is released.

ðŸ‘‰ Semaphore is commonly used to **limit concurrent access** (e.g., DB connections, thread pools).

---

## 2. Semaphore Constructors

```java
Semaphore(int permits)
Semaphore(int permits, boolean fair)
```

### Explanation:

* **permits** â†’ Number of threads allowed to access the resource concurrently.
* **fair**

  * `true` â†’ Threads acquire permits in FIFO (first-come-first-served) order.
  * `false` (default) â†’ No ordering guarantee (better performance).

---

## 3. Key Methods of Semaphore

| Method               | Description                                 |
| -------------------- | ------------------------------------------- |
| `acquire()`          | Acquires a permit, blocks if unavailable    |
| `release()`          | Releases a permit                           |
| `availablePermits()` | Returns number of free permits              |
| `tryAcquire()`       | Acquires permit if available (non-blocking) |

---

## 4. Example Code Using Semaphore

### Scenario:

* **Semaphore permits = 2**
* **6 threads**
* At most **2 threads run concurrently**
* Others wait until a permit is released

---

### Code Implementation

```java
import java.util.concurrent.Semaphore;

class MyThread extends Thread {
    private Semaphore s;

    public MyThread(String name, Semaphore s) {
        super(name);
        this.s = s;
    }

    @Override
    public void run() {
        try {
            s.acquire(); // Acquire permit

            for (int i = 0; i < 5; i++) {
                Thread.sleep(500);
                System.out.println(getName() + " : " + i);
            }

        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        s.release(); // Release permit
    }
}

public class Main {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2);
        MyThread[] threads = new MyThread[6];

        for (int i = 0; i < 6; i++) {
            threads[i] = new MyThread("Thread " + (i + 1), semaphore);
            threads[i].start();
        }
    }
}
```

---

## 5. Output Explanation

### Sample Output

```
Thread 1 : 0
Thread 2 : 0
Thread 2 : 1
Thread 1 : 1
Thread 2 : 2
Thread 1 : 2
Thread 2 : 3
Thread 1 : 3
Thread 2 : 4
Thread 1 : 4

Thread 3 : 0
Thread 4 : 0
Thread 3 : 1
Thread 4 : 1
Thread 4 : 2
Thread 3 : 2
Thread 3 : 3
Thread 4 : 3
Thread 3 : 4
Thread 4 : 4

Thread 6 : 0
Thread 5 : 0
Thread 6 : 1
Thread 5 : 1
Thread 6 : 2
Thread 5 : 2
Thread 6 : 3
Thread 5 : 3
Thread 5 : 4
Thread 6 : 4
```

---

## 6. Output Analysis

* Semaphore allows **only 2 threads at a time**
* Execution happens in **groups of 2 threads**

  * First: Thread 1 & Thread 2
  * Then: Thread 3 & Thread 4
  * Then: Thread 5 & Thread 6
* Remaining threads **wait** until permits are released
* Order may vary because fairness is not enabled

---

## 7. Important Observations

âœ” Semaphore controls **concurrency**, not mutual exclusion
âœ” Unlike `synchronized`, multiple threads can enter the critical section
âœ” Useful when you want **limited parallelism**

---

## 8. When to Use Semaphore?

* Database connection pool
* Rate limiting
* Limiting API calls
* Resource management
* Thread pool control

---

## 9. Semaphore vs synchronized (Quick Comparison)

| Feature          | Semaphore         | synchronized     |
| ---------------- | ----------------- | ---------------- |
| Permits          | Multiple          | Only 1           |
| Fairness         | Optional          | No               |
| Explicit release | Yes               | Automatic        |
| Use case         | Resource limiting | Mutual exclusion |

---

