
---

# ğŸ“Œ `java.util.concurrent` â€“ ReentrantLock Notes

## 1ï¸âƒ£ Why ReentrantLock?

* With the **`synchronized` keyword**, we lock **any object**
* But `synchronized`:

  * Does **not guarantee fairness**
  * A thread waiting for a long time may **never get the lock**
* To solve this **starvation problem**, Java provides **ReentrantLock**

---

## 2ï¸âƒ£ ReentrantLock Overview

* Class: `ReentrantLock`
* Package:

  ```java
  java.util.concurrent.locks
  ```
* Implements: `Lock` interface
* Parent class: `Object`

```java
ReentrantLock â†’ implements Lock â†’ extends Object
```

---

## 3ï¸âƒ£ ReentrantLock Constructors

### ğŸ”¹ Constructor 1: Default

```java
public ReentrantLock()
```

* Lock is given to a **random thread**
* Behavior is **similar to synchronized keyword**
* âŒ No fairness guarantee

---

### ğŸ”¹ Constructor 2: Fairness-based

```java
public ReentrantLock(boolean fair)
```

| `fair` value | Behavior                                       |
| ------------ | ---------------------------------------------- |
| `true`       | Longest waiting thread gets the lock           |
| `false`      | Random thread gets the lock (default behavior) |

âœ” `fair = true` â†’ **prevents starvation**
âœ” `fair = false` â†’ same as `synchronized`

---

## 4ï¸âƒ£ Program WITHOUT Lock (Unpredictable Output)

### ğŸ”¹ MyThread.java

```java
class MyThread extends Thread
{
    public MyThread(String name)
    {
        super(name);
    }

    @Override
    public void run()
    {
        for(int i = 0; i < 5; i++)
        {
            try
            {
                Thread.sleep(500);
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + " : " + i);
        }
    }
}
```

---

### ğŸ”¹ Main.java

```java
public class Main
{
    public static void main(String[] args)
    {
        MyThread thread1 = new MyThread("Thread 1");
        MyThread thread2 = new MyThread("Thread 2");

        thread1.start();
        thread2.start();
    }
}
```

---

### ğŸ”¹ Output (Unpredictable)

```
Thread 1 : 0
Thread 2 : 0
Thread 1 : 1
Thread 2 : 1
Thread 1 : 2
Thread 2 : 2
Thread 1 : 3
Thread 2 : 3
Thread 1 : 4
Thread 2 : 4
```

ğŸ“Œ **Reason:**
No locking â†’ both threads freely access CPU â†’ **race condition**

---

## 5ï¸âƒ£ Using ReentrantLock

### ğŸ”¹ Key Method

```java
public void lock()
```

* Acquires lock if available
* If not â†’ thread waits
* Similar to `synchronized`
* Must be followed by `unlock()`

---

## 6ï¸âƒ£ Program WITH ReentrantLock

### ğŸ”¹ MyThread.java

```java
import java.util.concurrent.locks.ReentrantLock;

class MyThread extends Thread
{
    ReentrantLock lock;

    public MyThread(String name, ReentrantLock lock)
    {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run()
    {
        lock.lock();

        for(int i = 0; i < 5; i++)
        {
            try
            {
                Thread.sleep(500);
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + " : " + i);
        }

        lock.unlock();
    }
}
```

---

### ğŸ”¹ Main.java

```java
import java.util.concurrent.locks.ReentrantLock;

public class Main
{
    public static void main(String[] args)
    {
        ReentrantLock lock = new ReentrantLock();

        MyThread thread1 = new MyThread("Thread 1", lock);
        MyThread thread2 = new MyThread("Thread 2", lock);

        thread1.start();
        thread2.start();
    }
}
```

---

### ğŸ”¹ Output (Ordered)

```
Thread 2 : 0
Thread 2 : 1
Thread 2 : 2
Thread 2 : 3
Thread 2 : 4
Thread 1 : 0
Thread 1 : 1
Thread 1 : 2
Thread 1 : 3
Thread 1 : 4
```

ğŸ“Œ **Explanation:**

* Both threads share the **same ReentrantLock**
* Only **one thread executes critical section**
* Other thread waits until `unlock()` is called

---

## 7ï¸âƒ£ Reentrant Nature (Very Important)

### ğŸ”¹ Locking Twice

```java
lock.lock();
lock.lock();
```

* Same thread can acquire the same lock **multiple times**
* This is why itâ€™s called **Reentrant**

---

### ğŸ”¹ âŒ Bug: Unlock Only Once

```java
lock.lock();
lock.lock();
lock.unlock(); // âŒ only once
```

ğŸš¨ Program will **hang**

* Lock count = 2
* Unlock count = 1
* Lock never fully released

---

### ğŸ”¹ âœ… Correct Way

```java
lock.lock();
lock.lock();

lock.unlock();
lock.unlock();
```

âœ” Lock count = Unlock count
âœ” Program executes normally

---

## 8ï¸âƒ£ Fair Lock Example

### ğŸ”¹ Creating Fair Lock

```java
ReentrantLock lock = new ReentrantLock(true);
```

ğŸ“Œ Behavior:

* Thread waiting **longest** gets the lock first
* Prevents starvation
* Slightly **less performance** than unfair lock

---

## 9ï¸âƒ£ ReentrantLock vs synchronized

| Feature              | synchronized | ReentrantLock |
| -------------------- | ------------ | ------------- |
| Fairness             | âŒ No         | âœ… Optional    |
| Explicit lock/unlock | âŒ No         | âœ… Yes         |
| Reentrant            | âœ… Yes        | âœ… Yes         |
| Interruptible lock   | âŒ No         | âœ… Yes         |
| Try lock             | âŒ No         | âœ… Yes         |

---

## ğŸ”Ÿ Key Takeaways (Interview Gold â­)

* `ReentrantLock` gives **better control** than `synchronized`
* Always use **try-finally** in real projects
* **Lock count must match unlock count**
* Use `fair = true` only when fairness is required
* `synchronized` is simpler, `ReentrantLock` is more powerful

---
