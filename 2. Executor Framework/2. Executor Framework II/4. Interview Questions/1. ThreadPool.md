
---

# Java Executor Framework â€“ Interview Questions ğŸ“˜ğŸ§µ

## 1ï¸âƒ£ Difference between `execute()` and `submit()`

### ğŸ”¹ `execute()`

* Accepts **only `Runnable`**
* **Does NOT return** anything
* Exceptions are **not propagated** to the caller

### ğŸ”¹ `submit()`

* Accepts **`Runnable` and `Callable`**
* Returns a **`Future`**
* Exceptions are captured and thrown on `future.get()`

### âœ… Key Interview Line

> `execute()` is fire-and-forget, while `submit()` allows result tracking and exception handling via `Future`.

### ğŸ“Œ Code Example

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

// Runnable using execute()
executor.execute(() -> System.out.println("Runnable executed"));

// Callable using submit()
Future<Integer> future = executor.submit(() -> 42);

System.out.println("Callable result: " + future.get());

executor.shutdown();
```

### ğŸ–¥ Output

```
Runnable executed
Callable result: 42
```

---

## 2ï¸âƒ£ How does `ThreadPoolExecutor` decide to create a thread or queue a task?

### ğŸ§  Decision Flow

1. If **running threads < corePoolSize** â†’ create a new thread
2. Else â†’ **queue the task**
3. If queue is full **AND** threads < maximumPoolSize â†’ create new thread
4. If queue is full **AND** threads == maximumPoolSize â†’ **reject task**

### ğŸ“Œ Constructor Syntax

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue
);
```

### âœ… Key Interview Line

> ThreadPoolExecutor prioritizes core threads, then queueing, then max threads, and finally rejection.

---

## 3ï¸âƒ£ What happens if you donâ€™t shut down an `ExecutorService`?

### âŒ Problems

* Executor threads **keep running**
* JVM **wonâ€™t terminate**
* Leads to **memory leaks & resource exhaustion**

### âœ… Best Practice

Always shut down executors.

### ğŸ“Œ Shutdown Options

```java
executor.shutdown();     // Graceful shutdown
executor.shutdownNow();  // Abrupt shutdown
```

### âœ… Key Interview Line

> Non-daemon executor threads prevent JVM shutdown if the executor is not explicitly closed.

---

## 4ï¸âƒ£ `scheduleAtFixedRate()` vs `scheduleWithFixedDelay()` â±ï¸

### ğŸ”¹ `scheduleAtFixedRate`

* Executes tasks at a **fixed time interval**
* Ignores task execution time
* Tasks **may overlap**

### ğŸ”¹ `scheduleWithFixedDelay`

* Waits for task to **finish**
* Then waits for the **delay**
* No overlapping executions

### ğŸ“Œ Method Signatures

```java
ScheduledFuture<?> scheduleAtFixedRate(
    Runnable command, long initialDelay, long period, TimeUnit unit);

ScheduledFuture<?> scheduleWithFixedDelay(
    Runnable command, long initialDelay, long delay, TimeUnit unit);
```

### ğŸ“Œ Example

```java
ScheduledExecutorService scheduler =
        Executors.newScheduledThreadPool(1);

scheduler.scheduleAtFixedRate(
    () -> System.out.println("Fixed Rate Task"),
    0, 2, TimeUnit.SECONDS
);

scheduler.scheduleWithFixedDelay(
    () -> System.out.println("Fixed Delay Task"),
    0, 2, TimeUnit.SECONDS
);
```

### ğŸ§  Interview Analogy

* **Fixed Rate** â†’ Wall clock based â°
* **Fixed Delay** â†’ Task completion based â³

---

## 5ï¸âƒ£ Handling Exceptions in ExecutorService Tasks

### ğŸ”¹ Using `submit()` + `Future`

* Exceptions are wrapped in `ExecutionException`
* Thrown when calling `future.get()`

### ğŸ“Œ Example

```java
ExecutorService executor = Executors.newSingleThreadExecutor();

Future<Integer> future = executor.submit(() -> {
    throw new RuntimeException("Boom!");
});

try {
    future.get();
} catch (ExecutionException e) {
    System.out.println("Caught: " + e.getCause());
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}

executor.shutdown();
```

### ğŸ–¥ Output

```
Caught: java.lang.RuntimeException: Boom!
```

---

### ğŸ”¹ Handling Inside the Task (Safest)

```java
executor.submit(() -> {
    try {
        throw new RuntimeException("Handled inside task");
    } catch (Exception e) {
        System.out.println("Caught in task: " + e.getMessage());
    }
});
```

### âœ… Key Interview Line

> `submit()` captures exceptions in `Future`, while handling inside the task provides immediate recovery.
---

## âœ… Final Conclusion (Interview-Ready)

* Executor Framework **abstracts thread management**
* Improves **performance, scalability & safety**
* Prevents manual thread misuse
* Essential for **async tasks, scheduling & parallel processing**

> Mastering `ExecutorService` and `ScheduledExecutorService` is critical for building **predictable, high-performance Java applications** ğŸš€

---
