
---

# Cached Thread Pool Executor in Java

## 1. What is a Cached Thread Pool?

A **Cached Thread Pool** is a type of `ExecutorService` provided by Java that:

* **Creates threads dynamically as needed**
* **Reuses existing idle threads**
* **Automatically removes idle threads after a timeout**

It is best suited for:

* **Short-lived, asynchronous tasks**
* **Applications with unpredictable or bursty workloads**

---

## 2. Key Characteristics

| Feature             | Description                                  |
| ------------------- | -------------------------------------------- |
| Thread count        | **Not fixed** (can grow as needed)           |
| Task Queue          | `SynchronousQueue`                           |
| Thread reuse        | Yes                                          |
| Idle thread timeout | **60 seconds**                               |
| Upper thread limit  | Practically unbounded (dangerous if misused) |
| Auto-scaling        | Yes                                          |

---

## 3. Code Demonstration

### 3.1 Task Class (Runnable)

```java
class TaskOne implements Runnable {

    private final int taskId;

    public TaskOne(int taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        System.out.println(
            "Task " + taskId + " being executed by " +
            Thread.currentThread().getName()
        );

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

### 3.2 Main Class â€“ Cached Thread Pool Demo

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPoolDemo {

    public static void main(String[] args) {

        try (ExecutorService service = Executors.newCachedThreadPool()) {

            for (int i = 0; i < 1000; i++) {
                service.execute(new TaskOne(i));
            }
        }
    }
}
```

---

## 4. Sample Output (Partial)

```text
Task 0 being executed by pool-1-thread-1
Task 1 being executed by pool-1-thread-2
Task 2 being executed by pool-1-thread-3
Task 3 being executed by pool-1-thread-4
Task 4 being executed by pool-1-thread-5
Task 27 being executed by pool-1-thread-28
Task 41 being executed by pool-1-thread-42
...
```

### ðŸ” Observation

* Thread numbers increase rapidly
* Each task may run on a **newly created thread**
* Threads are **not reused immediately** when tasks arrive fast

---

## 5. Why No Thread Count is Passed?

```java
Executors.newCachedThreadPool()
```

Unlike:

```java
Executors.newFixedThreadPool(5)
```

Cached thread pool:

* **Does not require a fixed number**
* Creates threads **on demand**
* Grows and shrinks automatically

---

## 6. Internal Working (Very Important)

### 6.1 Task Queue â€“ `SynchronousQueue`

* Holds **only ONE task at a time**
* Does **not store tasks**
* Direct handoff between task submitter and thread

ðŸ‘‰ If no thread is available to accept the task:

* A **new thread is created**

---

### 6.2 Thread Creation Logic

1. Task submitted
2. Executor checks for **idle thread**
3. If found â†’ reuse it
4. If NOT found â†’ **create new thread**
5. Thread executes task immediately

ðŸ“Œ Example:

* 10 tasks â†’ 10 threads
* 11th task â†’ 11th thread created

---

### 6.3 Thread Termination (Guard Rail)

* Idle threads are terminated after **60 seconds**
* Prevents unlimited thread accumulation

```text
Idle Time Limit = 60 seconds
```

---

## 7. Auto-Scaling Nature

| Scenario              | Behavior                     |
| --------------------- | ---------------------------- |
| High load             | Threads are created          |
| Low load              | Idle threads are killed      |
| Burst traffic         | Handles efficiently          |
| Continuous heavy load | Can exhaust system resources |

---

## 8. Advantages

âœ… Excellent for short-lived tasks
âœ… Automatic scaling
âœ… No queue backlog
âœ… Fast execution

---

## 9. Disadvantages âš ï¸

âŒ Can create **too many threads**
âŒ Risk of **OutOfMemoryError**
âŒ Not suitable for CPU-intensive tasks
âŒ No backpressure mechanism

---

## 10. When to Use Cached Thread Pool?

âœ” IO-bound tasks
âœ” Short asynchronous jobs
âœ” Microservices request handling
âœ” Lightweight background tasks

âŒ Avoid for:

* Long-running tasks
* CPU-intensive workloads
* Systems with limited memory

---

## 11. Core Takeaways

* Uses `SynchronousQueue`
* No fixed thread limit
* Threads auto-created and auto-destroyed
* Idle timeout = **60 seconds**
* Extremely powerful but must be used carefully

---
