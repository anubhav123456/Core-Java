# Producer–Consumer Problem in Java (Using `wait()` & `notify()`)

---

## 1. What is the Producer–Consumer Problem?

The **Producer–Consumer Problem** is a classic **synchronization problem** in concurrent programming.

* **Producer thread(s)** generate data and put it into a **shared buffer**.
* **Consumer thread(s)** retrieve and process data from the same buffer.
* The buffer has **limited capacity**.

### Key Constraints

* If the **buffer is full**, the **producer must wait**.
* If the **buffer is empty**, the **consumer must wait**.
* Proper synchronization is required to avoid:

  * Race conditions
  * Data inconsistency
  * Busy waiting

This problem is commonly used to explain:

* `synchronized`
* `wait()`
* `notify()` / `notifyAll()`

---

## 2. Conceptual Diagram (Mental Model)

```
Producer  --->  [ Shared Buffer ]  --->  Consumer
               (limited capacity)
```

---

## 3. Basic Implementation (Single Slot Buffer)

### 3.1 Main Class

```java
public class Main {

    public static void main(String[] args) {
        Buffer buffer = new Buffer();

        Producer producer = new Producer(buffer);
        Consumer consumer = new Consumer(buffer);

        producer.start();
        consumer.start();
    }
}
```

---

### 3.2 Buffer Class (Shared Resource)

```java
class Buffer {

    private int data;
    private boolean hasData = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (hasData) {
            wait(); // wait if buffer is full
        }

        data = value;
        hasData = true;
        System.out.println("Produced: " + data);

        notify(); // notify consumer
    }

    public synchronized void consume() throws InterruptedException {
        while (!hasData) {
            wait(); // wait if buffer is empty
        }

        System.out.println("Consumed: " + data);
        hasData = false;

        notify(); // notify producer
    }
}
```

### Explanation

* `synchronized` ensures mutual exclusion
* `wait()` releases the monitor lock and pauses the thread
* `notify()` wakes up one waiting thread
* `while` is used (not `if`) to handle **spurious wakeups**

---

### 3.3 Producer Thread

```java
class Producer extends Thread {

    private Buffer buffer;

    Producer(Buffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        int value = 1;
        try {
            while (true) {
                buffer.produce(value++);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 3.4 Consumer Thread

```java
class Consumer extends Thread {

    private Buffer buffer;

    Consumer(Buffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        try {
            while (true) {
                buffer.consume();
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 3.5 Sample Output

```
Produced: 1
Consumed: 1
Produced: 2
Consumed: 2
Produced: 3
Consumed: 3
```

---

## 4. Extended Version (Bounded Buffer using List)

Here the buffer can store **multiple elements**.

---

### 4.1 Main Class

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        Buffer buffer = new Buffer(5);

        Producer producer = new Producer(buffer);
        Consumer consumer = new Consumer(buffer);

        producer.start();
        consumer.start();
    }
}
```

---

### 4.2 Buffer Class (Bounded Buffer)

```java
class Buffer {

    private final List<Integer> buffer;
    private final int capacity;

    public Buffer(int capacity) {
        this.buffer = new ArrayList<>();
        this.capacity = capacity;
    }

    public synchronized void produce(int value) throws InterruptedException {
        while (buffer.size() == capacity) {
            System.out.println("Container full, waiting for items to be removed");
            wait();
        }

        buffer.add(value);
        System.out.println("Produced: " + value +
                " | Buffer size: " + buffer.size());

        notifyAll();
    }

    public synchronized void consume() throws InterruptedException {
        while (buffer.isEmpty()) {
            System.out.println("Container empty, waiting for items to be added");
            wait();
        }

        int value = buffer.remove(0);
        System.out.println("Consumed: " + value +
                " | Buffer size: " + buffer.size());

        notifyAll();
    }
}
```

### Why `notifyAll()`?

* Supports **multiple producers and consumers**
* Prevents deadlock caused by waking the wrong thread

---

### 4.3 Producer Thread

```java
class Producer extends Thread {

    private Buffer buffer;

    Producer(Buffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        int value = 0;
        try {
            while (true) {
                buffer.produce(value++);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 4.4 Consumer Thread

```java
class Consumer extends Thread {

    private Buffer buffer;

    Consumer(Buffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        try {
            while (true) {
                buffer.consume();
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 4.5 Sample Output

```
Produced: 0 | Buffer size: 1
Produced: 1 | Buffer size: 2
Produced: 2 | Buffer size: 3
Produced: 3 | Buffer size: 4
Produced: 4 | Buffer size: 5
Container full, waiting for items to be removed
Consumed: 0 | Buffer size: 4
Consumed: 1 | Buffer size: 3
Consumed: 2 | Buffer size: 2
Consumed: 3 | Buffer size: 1
Consumed: 4 | Buffer size: 0
Container empty, waiting for items to be added
```

---

## 5. Key Points to Remember

* Always call `wait()` inside a **loop**
* `wait()` and `notify()` must be called from **synchronized context**
* `wait()` releases the lock, `sleep()` does NOT
* Prefer `notifyAll()` in real-world scenarios

---

## 6. Modern Alternative (For Knowledge)

Java provides higher-level concurrency utilities:

* `BlockingQueue`
* `ArrayBlockingQueue`
* `LinkedBlockingQueue`

These handle synchronization internally and are **preferred in production code**.

---

## 7. Summary

* Producer–Consumer demonstrates **inter-thread communication**
* Uses `synchronized`, `wait()`, `notify()/notifyAll()`
* Helps understand low-level thread coordination
* Foundation for advanced concurrency concepts

---
