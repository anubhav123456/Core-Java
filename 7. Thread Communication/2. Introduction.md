
---

# üßµ Thread Communication in Java (wait / notify / notifyAll)

Thread communication is a **core concurrency concept** that allows multiple threads to **coordinate execution and share data safely**.

Used mainly when:

* One thread **waits for a condition**
* Another thread **changes the condition and notifies**

üëâ Common real-world example: **Producer‚ÄìConsumer**, **Kafka consumers**, **shared queues**

---

## üîë Core Concepts

### 1Ô∏è‚É£ Monitor (Intrinsic Lock)

* Every Java object has a **monitor**
* `synchronized`, `wait()`, `notify()`, `notifyAll()` all work on this monitor
* **Only one thread can own the monitor at a time**

---

## üí§ `wait()`

### What it does

* Releases the **monitor lock**
* Puts the thread into **WAITING state**
* Thread resumes **only after notification + lock re-acquisition**

### Key Rules

* Must be called inside `synchronized`
* Always used inside a **while loop** (spurious wakeups)

### Use Case

* Consumer waiting for producer to produce data

```java
while (!conditionMet) {
    lock.wait();
}
```

---

## üîî `notify()`

### What it does

* Wakes **one arbitrary waiting thread**
* That thread must **re-acquire the lock** before continuing

### Use Case

* Only **one resource** becomes available

‚ö†Ô∏è Risk: Other threads may **wait forever**

---

## üì£ `notifyAll()`

### What it does

* Wakes **all waiting threads**
* Still, **only one thread executes at a time**

### Use Case

* Condition change relevant to **all waiting threads**
* Kafka-style pub-sub, multiple consumers

---

## ‚ö†Ô∏è Important Rules (VERY IMPORTANT ‚ùó)

‚úî Must be called inside `synchronized`
‚úî Must use **shared condition variable**
‚úî Must re-check condition using **while**, not `if`
‚úî Notification ‚â† immediate execution (lock must be free)

---

## üß™ Example Code: Wait / Notify / NotifyAll

### üîπ Shared Class

```java
// WaitNotifyDemo.java
class WaitNotifyDemo {

    // Lock object used for synchronization
    private final Object lock = new Object();

    // Shared condition flag
    private boolean conditionMet = false;

    // Method where threads wait until conditionMet becomes true
    public void doWait() {
        synchronized (lock) {
            while (!conditionMet) { // Handle spurious wakeups
                try {
                    System.out.println(Thread.currentThread().getName() + " is waiting");
                    lock.wait(); // Releases lock and waits
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println(Thread.currentThread().getName() + " was interrupted");
                }
            }
            System.out.println(Thread.currentThread().getName() + " resumed execution");
        }
    }

    // Notify only ONE waiting thread
    public void doNotify() {
        synchronized (lock) {
            conditionMet = true;
            System.out.println(Thread.currentThread().getName() + " called notify()");
            lock.notify();
        }
    }

    // Notify ALL waiting threads
    public void doNotifyAll() {
        synchronized (lock) {
            conditionMet = true;
            System.out.println(Thread.currentThread().getName() + " called notifyAll()");
            lock.notifyAll();
        }
    }
}

```

---

## ‚ñ∂Ô∏è Main Class

```java
// Main.java
public class Main {

    public static void main(String[] args) {

        // ======================================
        // Demonstrating notifyAll()
        // ======================================
        System.out.println("===== Demonstrating notifyAll() =====");

        WaitNotifyDemo demoAll = new WaitNotifyDemo();

        Thread waiter1 = new Thread(demoAll::doWait, "Waiter-1");
        Thread waiter2 = new Thread(demoAll::doWait, "Waiter-2");
        Thread waiter3 = new Thread(demoAll::doWait, "Waiter-3");

        waiter1.start();
        waiter2.start();
        waiter3.start();

        // Ensure all threads enter waiting state
        sleep(2000);

        Thread notifierAll = new Thread(demoAll::doNotifyAll, "Notifier-All");
        notifierAll.start();

        join(waiter1, waiter2, waiter3, notifierAll);

        // ======================================
        // Demonstrating notify()
        // ======================================
        System.out.println("\n===== Demonstrating notify() =====");

        WaitNotifyDemo demoNotify = new WaitNotifyDemo();

        Thread waiterA = new Thread(demoNotify::doWait, "Waiter-A");
        Thread waiterB = new Thread(demoNotify::doWait, "Waiter-B");

        waiterA.start();
        waiterB.start();

        sleep(2000);

        Thread notifier = new Thread(demoNotify::doNotify, "Notifier");
        notifier.start();

        // One thread remains waiting ‚Üí wake it explicitly
        sleep(2000);
        System.out.println("Calling notifyAll() to wake remaining thread");

        Thread notifier2 = new Thread(demoNotify::doNotifyAll, "Notifier-2");
        notifier2.start();

        join(waiterA, waiterB, notifier, notifier2);

        System.out.println("\nMain thread: Execution finished");
    }

    // Utility sleep method
    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // Utility join method
    private static void join(Thread... threads) {
        for (Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

---

## üñ® Sample Output (notifyAll)

```
===== Demonstrating notifyAll() =====
Waiter-1 is waiting
Waiter-2 is waiting
Waiter-3 is waiting
Notifier-All called notifyAll()
Waiter-2 resumed execution
Waiter-1 resumed execution
Waiter-3 resumed execution
```

---

## üñ® Sample Output (notify)

```
===== Demonstrating notify() =====
Waiter-A is waiting
Waiter-B is waiting
Notifier called notify()
Waiter-B resumed execution
Calling notifyAll() to wake remaining thread
Notifier-2 called notifyAll()
Waiter-A resumed execution

Main thread: Execution finished
```

‚ö†Ô∏è **Execution order may vary** due to thread scheduling.


---

## üß† Execution Flow (Mental Model)

1. Thread enters `synchronized`
2. Condition not met ‚Üí `wait()`
3. Lock released
4. Another thread acquires lock ‚Üí `notify / notifyAll`
5. Notified thread competes for lock
6. Re-checks condition
7. Continues execution

---

## ‚öñÔ∏è Performance & Best Practices

* ‚úÖ Avoid excessive synchronization
* ‚úÖ Prefer `notifyAll()` unless you're 100% sure
* ‚úÖ Always guard conditions with `while`
* ‚úÖ Improper notify can cause **deadlocks & resource leaks**

---

## üìå Interview One-Liners

* `wait()` releases lock, `sleep()` does NOT
* `notify()` wakes one thread, `notifyAll()` wakes all
* Notification does **not guarantee execution**
* Always call inside `synchronized`
* Use `while`, not `if`

---




