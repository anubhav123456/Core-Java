
---

# Creating Threads in Java â€” Complete Notes

Java provides **multiple ways to create threads**, each suited for different use cases.

---

## 1. Creating a Thread by **Extending the `Thread` class**

### Concept

* Create a class that **extends `Thread`**
* Override the `run()` method
* Call `start()` to execute the thread

### Code

```java
public class MyThread extends Thread
{
    @Override
    public void run()
    {
        for (int i = 0; i < 5; i++)
        {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try
            {
                Thread.sleep(5000);
            }
            catch (InterruptedException e)
            {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

```java
public class Main
{
    public static void main(String[] args)
    {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();

        thread1.start();
        thread2.start();
    }
}
```

### Output (order may vary)

```
Thread-1 is running 0
Thread-0 is running 0
Thread-0 is running 1
Thread-1 is running 1
Thread-0 is running 2
Thread-1 is running 2
Thread-0 is running 3
Thread-1 is running 3
Thread-1 is running 4
Thread-0 is running 4
```

### Advantages

* Simple and easy to understand
* Direct access to Thread methods

### âŒ Drawback

* **Java does not support multiple inheritance**
* Once you extend `Thread`, you **cannot extend any other class**

---

## 2. Creating a Thread by **Implementing `Runnable` Interface**

### Concept

* Implement `Runnable`
* Override `run()`
* Pass the Runnable object to a `Thread` constructor

### Code

```java
public class MyRunnable implements Runnable
{
    @Override
    public void run()
    {
        for (int i = 0; i < 5; i++)
        {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try
            {
                Thread.sleep(5000);
            }
            catch (InterruptedException e)
            {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

```java
public class Main
{
    public static void main(String[] args)
    {
        MyRunnable runnable = new MyRunnable();

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);

        thread1.start();
        thread2.start();
    }
}
```

### Output (order may vary)

```
Thread-1 is running 0
Thread-0 is running 0
Thread-0 is running 1
Thread-1 is running 1
Thread-1 is running 2
Thread-0 is running 2
Thread-1 is running 3
Thread-0 is running 3
Thread-1 is running 4
Thread-0 is running 4
```

### Advantages

* Allows extending another class
* **Better design** (separates task from thread)
* Multiple threads can share the same Runnable instance

### Used Widely Because

* Works well with **Executor Framework**
* Cleaner, more flexible than extending `Thread`

---

## 3. Creating a Thread using **Callable Interface**

### Concept

* `Callable` is similar to `Runnable`, but:

  * **Returns a result**
  * **Can throw checked exceptions**
* Used with **ExecutorService**
* Result is obtained using `Future`

---

### Callable Task Code

```java
import java.util.concurrent.Callable;

public class MyCallable implements Callable<String>
{
    private final String name;

    public MyCallable(String name)
    {
        this.name = name;
    }

    @Override
    public String call() throws Exception
    {
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < 5; i++)
        {
            result
                .append("Callable ")
                .append(name)
                .append(" is running : ")
                .append(i)
                .append("\n");

            Thread.sleep(500);
        }
        return result.toString();
    }
}
```

---

### Main Class Using ExecutorService

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main
{
    public static void main(String[] args)
    {
        MyCallable callable1 = new MyCallable("Task 1");
        MyCallable callable2 = new MyCallable("Task 2");

        ExecutorService executor = Executors.newFixedThreadPool(2);

        try
        {
            Future<String> future1 = executor.submit(callable1);
            Future<String> future2 = executor.submit(callable2);

            System.out.println("Results from first task");
            System.out.println(future1.get());

            System.out.println("Results from second task");
            System.out.println(future2.get());
        }
        catch (InterruptedException | ExecutionException e)
        {
            System.out.println("Task execution interrupted: " + e.getMessage());
        }
        finally
        {
            executor.shutdown();
        }
    }
}
```

### Output

```
Results from first task
Callable Task 1 is running : 0
Callable Task 1 is running : 1
Callable Task 1 is running : 2
Callable Task 1 is running : 3
Callable Task 1 is running : 4

Results from second task
Callable Task 2 is running : 0
Callable Task 2 is running : 1
Callable Task 2 is running : 2
Callable Task 2 is running : 3
Callable Task 2 is running : 4
```

---

# Difference Between Runnable and Callable (Very Important ğŸ”¥)

| Feature            | Runnable       | Callable               |
| ------------------ | -------------- | ---------------------- |
| Package            | `java.lang`    | `java.util.concurrent` |
| Method             | `run()`        | `call()`               |
| Return Value       | âŒ No           | âœ… Yes                  |
| Checked Exceptions | âŒ Cannot throw | âœ… Can throw            |
| Used With          | `Thread`       | `ExecutorService`      |
| Result Handling    | âŒ No result    | âœ… Uses `Future`        |
| Java Version       | Since Java 1.0 | Since Java 5           |

### Runnable

```java
public void run()
```

### Callable

```java
public V call() throws Exception
```

---

# When to Use What?

âœ… **Extend Thread**

* Small demo programs
* Learning basics (not recommended for real projects)

âœ… **Runnable**

* Most common
* When no return value is needed
* Works well with thread pools

âœ… **Callable**

* When you need:

  * Return values
  * Exception handling
  * Advanced concurrency
* Used heavily in **production systems**

---

### â­ Interview Tip

> *â€œCallable is preferred over Runnable when we need a return value or exception handling. Runnable is simpler but limited.â€*

---

### â­ What is Thread Safety and How Can It Be Achieved?

**Thread safety** refers to code that functions correctly during simultaneous execution by multiple threads.

It can be achieved through:

- ğŸ”’ **Synchronization**
- ğŸ§Š **Immutable objects**
- ğŸ“¦ **Concurrent collections**
- âš›ï¸ **Atomic variables**
- ğŸ§µ **Thread-local variables**

---

### â­ What's the difference between `sleep()` and `wait()`?

- `sleep()` causes the current thread to pause for a specified time without releasing locks.
- `wait()` causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` on the same object, and it releases the lock on the object.
---