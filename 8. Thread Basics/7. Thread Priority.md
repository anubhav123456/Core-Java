
---

## Thread Priority in Java

### 1. Thread Scheduler

* When **multiple threads are in Runnable state** and **only one CPU** is available, **only one thread can execute at a time**.
* The **Thread Scheduler** (part of JVM + OS) decides:

  * **Which thread gets CPU time**
  * **For how long**
* The decision is **not fully controlled by Java**, it depends on the **underlying OS scheduling algorithm**.

---

### 2. Thread Priority Concept

* Each thread has a **priority** that hints the scheduler about its importance.
* **Higher priority thread → more chance of getting CPU time** (not guaranteed).

#### Priority Range in Java

| Constant                         | Value |
| -------------------------------- | ----- |
| `Thread.MIN_PRIORITY`            | 1     |
| `Thread.NORM_PRIORITY` (default) | 5     |
| `Thread.MAX_PRIORITY`            | 10    |

* Default priority of **main thread = 5**
* Child threads inherit **parent thread’s priority**

---

### 3. FIFO for Same Priority

* If multiple threads have **same priority**, they are executed in **FIFO (First In First Out)** order.
* Scheduler internally maintains a **queue** for threads of equal priority.

---

## Example 1: Checking and Updating Thread Priority

### Code

```java
public class Main
{
    public static void main(String[] args)
    {
        System.out.println(Thread.currentThread().getName()
                + " thread's current priority is "
                + Thread.currentThread().getPriority());

        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);

        System.out.println(Thread.currentThread().getName()
                + " thread's updated priority is "
                + Thread.currentThread().getPriority());
    }
}
```

### Output

```
main thread's current priority is 5
main thread's updated priority is 10
```

### Explanation

* `Thread.currentThread()` returns the **currently executing thread** (main thread).
* Default priority is **5 (NORM_PRIORITY)**.
* Priority is updated to **10 (MAX_PRIORITY)** using `setPriority()`.

---

## 4. Important Observations About Thread Priority

* **Thread priority is just a hint**, not a command.
* **Execution order is never guaranteed**, even if priorities differ.
* **Short tasks**:

  * Finish too quickly
  * Scheduler may not even consider priority
* **Long, CPU-bound tasks**:

  * Priority may show a **relative advantage**
  * Higher priority threads may get **more CPU time**

---

## Example 2: Priority Impact on CPU-bound Threads

### Code

```java
public class Main
{
    public static volatile boolean running = true;

    public static void main(String[] args) throws InterruptedException
    {
        Thread lowPriority = new Thread(() -> {
            long count = 0;
            while (running) {
                count++;
            }
            System.out.println("Low Priority Count : " + count);
        }, "LOW");

        Thread highPriority = new Thread(() -> {
            long count = 0;
            while (running) {
                count++;
            }
            System.out.println("High Priority Count: " + count);
        }, "HIGH");

        lowPriority.setPriority(Thread.MIN_PRIORITY);  // 1
        highPriority.setPriority(Thread.MAX_PRIORITY); // 10

        lowPriority.start();
        highPriority.start();

        // Let both threads run for 3 seconds
        Thread.sleep(3000);
        running = false;
    }
}
```

### Output (Sample)

```
Low Priority Count : 5871264007
High Priority Count: 5977135348
```

---

### Explanation

* Both threads run **CPU-bound loops** for 3 seconds.
* `volatile boolean running` ensures **visibility across threads**.
* **High-priority thread performs slightly more operations**, showing:

  * Priority can give **relative CPU advantage**
  * But **low-priority thread still executes**
---

### One-Line Interview Summary

> *Thread priority is a scheduling hint to the JVM/OS that may influence CPU allocation, but execution order is never guaranteed.*

---
