
---

## 1Ô∏è‚É£ What is PriorityBlockingQueue in Java?

`PriorityBlockingQueue` is a **thread-safe, unbounded blocking queue** that:

* Orders elements **by priority**
* Uses **natural ordering** (`Comparable`) or a **custom Comparator**
* Is part of `java.util.concurrent`
* **Does NOT block on put()** (because it‚Äôs unbounded)
* **Blocks on take()** if the queue is empty

### Package

```java
java.util.concurrent.PriorityBlockingQueue
```

---

## 2Ô∏è‚É£ Key Characteristics

| Feature           | Description                          |
| ----------------- | ------------------------------------ |
| Thread-safe       | Yes                                  |
| Ordering          | Priority-based (min-heap by default) |
| Blocking behavior | `take()` blocks if empty             |
| Capacity          | Unbounded                            |
| FIFO?             | ‚ùå No (priority-based)                |
| Allows null?      | ‚ùå No                                 |

---

## 3Ô∏è‚É£ How Ordering Works

### Default (Natural Ordering)

* Smallest element has **highest priority**

Example:

```java
PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
queue.add(10);
queue.add(5);
queue.add(20);
```

Order of removal:

```
5 ‚Üí 10 ‚Üí 20
```

---

### Custom Object Priority

You must either:

* Implement `Comparable`
* OR pass a `Comparator`

---

## 4Ô∏è‚É£ Why Use PriorityBlockingQueue?

‚úî Task scheduling
‚úî Job queues
‚úî Thread pools
‚úî Producer‚ÄìConsumer with priority
‚úî Event processing

---

## 5Ô∏è‚É£ Producer‚ÄìConsumer Problem Using PriorityBlockingQueue

### Problem Statement

* **Producer** produces tasks with priority
* **Consumer** consumes tasks based on priority
* Higher priority tasks are processed first

---

## 6Ô∏è‚É£ Task Class (Comparable)

```java
class Task implements Comparable<Task> {
    int priority;
    String name;

    Task(int priority, String name) {
        this.priority = priority;
        this.name = name;
    }

    @Override
    public int compareTo(Task other) {
        // Lower number = higher priority
        return Integer.compare(this.priority, other.priority);
    }

    @Override
    public String toString() {
        return "Task{name='" + name + "', priority=" + priority + "}";
    }
}
```

---

## 7Ô∏è‚É£ Producer Code

```java
import java.util.concurrent.PriorityBlockingQueue;

class Producer implements Runnable {

    private PriorityBlockingQueue<Task> queue;

    Producer(PriorityBlockingQueue<Task> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            queue.put(new Task(3, "Low Priority Task"));
            System.out.println("Produced: Low Priority Task");

            Thread.sleep(500);

            queue.put(new Task(1, "High Priority Task"));
            System.out.println("Produced: High Priority Task");

            Thread.sleep(500);

            queue.put(new Task(2, "Medium Priority Task"));
            System.out.println("Produced: Medium Priority Task");

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 8Ô∏è‚É£ Consumer Code

```java
class Consumer implements Runnable {

    private PriorityBlockingQueue<Task> queue;

    Consumer(PriorityBlockingQueue<Task> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                Task task = queue.take(); // blocks if empty
                System.out.println("Consumed: " + task);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 9Ô∏è‚É£ Main Class

```java
public class PriorityBlockingQueueDemo {

    public static void main(String[] args) {

        PriorityBlockingQueue<Task> queue = new PriorityBlockingQueue<>();

        Thread producerThread = new Thread(new Producer(queue));
        Thread consumerThread = new Thread(new Consumer(queue));

        producerThread.start();
        consumerThread.start();
    }
}
```

---

## üîü Sample Output

```
Produced: Low Priority Task
Produced: High Priority Task
Produced: Medium Priority Task

Consumed: Task{name='High Priority Task', priority=1}
Consumed: Task{name='Medium Priority Task', priority=2}
Consumed: Task{name='Low Priority Task', priority=3}
```

üëâ **Notice:**
Even though **Low Priority Task** was produced first, **High Priority Task** was consumed first.

---

## 1Ô∏è‚É£1Ô∏è‚É£ Important Interview Points ‚≠ê

### üîπ PBQ vs BlockingQueue

| BlockingQueue     | PriorityBlockingQueue |
| ----------------- | --------------------- |
| FIFO              | Priority-based        |
| Bounded/Unbounded | Always unbounded      |
| Order preserved   | Order NOT preserved   |

---

### üîπ Does PBQ block on put()?

‚ùå No (unbounded)

### üîπ Does PBQ block on take()?

‚úÖ Yes (if empty)

---

### üîπ Is PBQ suitable for Producer‚ÄìConsumer?

‚úÖ Yes, **when priority matters**

---

## 1Ô∏è‚É£2Ô∏è‚É£ When NOT to Use PBQ

‚ùå When FIFO order is mandatory
‚ùå When capacity limit is required

---

## 1Ô∏è‚É£3Ô∏è‚É£ One-Line Summary (Perfect for Interviews)

> **PriorityBlockingQueue** is a thread-safe, unbounded blocking queue that orders elements based on priority instead of insertion order, making it ideal for priority-based producer‚Äìconsumer problems.

---
