
---

## ArrayBlockingQueue (Java)

### ğŸ“Œ Definition

`ArrayBlockingQueue` is a **thread-safe**, **array-backed**, **bounded** implementation of the `BlockingQueue` interface present in `java.util.concurrent` package.

---

## ğŸ”‘ Key Characteristics

1. **Bounded Queue**

   * The size (capacity) is **fixed** at the time of creation.
   * Capacity **cannot be changed** later.

2. **Blocking Behavior**

   * `put()` â†’ **blocks** if the queue is **full**
   * `take()` â†’ **blocks** if the queue is **empty**

3. **FIFO Ordering**

   * Follows **First-In-First-Out**
   * Elements are:

     * **Inserted at tail**
     * **Removed from head**

4. **Thread Safety**

   * Internally uses locks to ensure safe access by multiple threads.

5. **Fairness Policy (Optional)**

   * Can enforce **FIFO order for waiting threads**
   * Fairness is enabled by passing `true` in constructor:

     ```java
     new ArrayBlockingQueue<>(capacity, true);
     ```

6. **Used In**

   * Classic **Producerâ€“Consumer problem**
   * Multithreaded applications where bounded buffers are required

---

## ğŸ“¦ Constructor

```java
ArrayBlockingQueue<E> queue = new ArrayBlockingQueue<>(capacity);
```

With fairness:

```java
ArrayBlockingQueue<E> queue = new ArrayBlockingQueue<>(capacity, true);
```

---

## ğŸš€ Producerâ€“Consumer Example using ArrayBlockingQueue

---

### ğŸ§‘â€ğŸ­ Producer Class

```java
import java.util.concurrent.ArrayBlockingQueue;

class Producer implements Runnable {
    private ArrayBlockingQueue<Integer> queue;

    public Producer(ArrayBlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Produced: " + i);
                queue.put(i); // blocks if queue is full
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

### ğŸ§‘â€ğŸ³ Consumer Class

```java
import java.util.concurrent.ArrayBlockingQueue;

class Consumer implements Runnable {
    private ArrayBlockingQueue<Integer> queue;

    public Consumer(ArrayBlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                Integer item = queue.take(); // blocks if queue is empty
                System.out.println("Consumed: " + item);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

### ğŸ§ª Main Class (Driver Code)

```java
import java.util.concurrent.ArrayBlockingQueue;

public class ProducerConsumerDemo {
    public static void main(String[] args) {
        ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);

        Thread producerThread = new Thread(new Producer(queue));
        Thread consumerThread = new Thread(new Consumer(queue));

        producerThread.start();
        consumerThread.start();
    }
}
```

---

## ğŸ–¥ï¸ Sample Output (One Possible Execution)

```
Produced: 1
Consumed: 1
Produced: 2
Produced: 3
Consumed: 2
Produced: 4
Consumed: 3
Produced: 5
Consumed: 4
Consumed: 5
```

âš ï¸ **Note:**
Actual output order may vary due to **thread scheduling**, but:

* FIFO order is always preserved
* Producer blocks if queue size reaches `3`
* Consumer blocks if queue is empty

---

## ğŸ§  Important Methods

| Method       | Description                                |
| ------------ | ------------------------------------------ |
| `put(E e)`   | Inserts element, blocks if full            |
| `take()`     | Removes element, blocks if empty           |
| `offer(E e)` | Inserts if possible, returns false if full |
| `poll()`     | Retrieves element or returns null          |
| `size()`     | Current number of elements                 |

---

## âœ… Advantages

* No manual synchronization required
* Prevents race conditions
* Ideal for producer-consumer problems
* Better than `wait()` / `notify()`

---

## âŒ Limitation

* Fixed capacity
* Cannot dynamically grow

---

## ğŸ“Œ Interview Tip (One-liner)

> **ArrayBlockingQueue** is a bounded, thread-safe, FIFO blocking queue that blocks producers when full and consumers when empty.

---
