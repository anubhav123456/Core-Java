
---

# ðŸ“˜ **Notes: Inheritance**
---


## âœ… **Inheritance**
- We can look at Inheritance as a form of code reuse.
- It's a way to organize classes into a parent-child hierarchy, which lets the child inherit (reuse), fields and methods from its parent.

```java
public class Animal {
    private String type;
    private String size;
    private double weight;

    public Animal() {
        System.out.println("Animal constructor called");
    }

    public Animal(String type, String size, double weight) {
        this.type = type;
        this.size = size;
        this.weight = weight;
    }

    @Override
    public String toString() {
        return "Animal{" +
                "type='" + type + '\'' +
                ", size='" + size + '\'' +
                ", weight=" + weight +
                '}';
    }

    public void move(String speed) {
        System.out.println(type + " moves " + speed);
    }

    public void makeNoise() {
        System.out.println(type + " makes some kind of noise");
    }
}

public class Dog extends Animal {
    private String earShape;
    private String tailShape;

    public Dog() {
        super("Mutt", "Big", 50);
    }

    public Dog(String type, double weight) {
        this(type, weight, "Perky", "Curled");
    }

    public Dog(String type, double weight, String earShape, String tailShape) {
        super(type,
                weight < 15 ? "Small" :
                (weight < 35 ? "Medium" : "Big"),
                weight);

        this.earShape = earShape;
        this.tailShape = tailShape;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "earShape='" + earShape + '\'' +
                ", tailShape='" + tailShape + '\'' +
                "} " + super.toString();
    }

    @Override
    public void move(String speed) {
        super.move(speed);
        System.out.println("Dog walk, run and wag their tail.");
    }

    @Override
    public void makeNoise() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {

        Animal animal = new Animal("Generic Animal", "Huge", 400);
        doAnimalStuff(animal, "slow");

        Dog dog = new Dog();
        doAnimalStuff(dog, "fast");

        Dog yorkie = new Dog("Yorkie", 15);
        doAnimalStuff(yorkie, "fast");

        Dog retriever = new Dog("Labrador Retriever", 65, "Floppy", "Swimmer");
        doAnimalStuff(retriever, "slow");
    }

    public static void doAnimalStuff(Animal animal, String speed) {
        System.out.println(animal);
        animal.makeNoise();
        animal.move(speed);
        System.out.println("- - - -");
    }
}

```

```text
Animal{type='Generic Animal', size='Huge', weight=400.0}
Generic Animal makes some kind of noise
Generic Animal moves slow
- - - -
Dog{earShape='null', tailShape='null'} Animal{type='Mutt', size='Big', weight=50.0}
Dog barks
Mutt moves fast
Dog walk, run and wag their tail.
- - - -
Dog{earShape='Perky', tailShape='Curled'} Animal{type='Yorkie', size='Medium', weight=15.0}
Dog barks
Yorkie moves fast
Dog walk, run and wag their tail.
- - - -
Dog{earShape='Floppy', tailShape='Swimmer'} Animal{type='Labrador Retriever', size='Big', weight=65.0}
Dog barks
Labrador Retriever moves slow
Dog walk, run and wag their tail.
- - - -

```
---

# âœ… **1. Classes: Animal and Dog (Inheritance)**

We have two classes:

### **Animal (Parent class / Superclass)**

Contains:

* `type`, `size`, `weight` â†’ **fields**
* Constructors
* `move()` â†’ method
* `makeNoise()` â†’ method
* `toString()` â†’ method override from Object class

### **Dog (Child class / Subclass) extends Animal**

Adds:

* `earShape`, `tailShape` â†’ additional fields
* Overloaded constructors
* Overrides:

  * `move()`
  * `makeNoise()`
  * `toString()`

This is **inheritance** â€” Dog inherits everything from Animal.

---

# âœ… 2. Constructors & Constructor Chaining

### **Animal class constructors**

```java
public Animal() {
    System.out.println("Animal constructor called");
}

public Animal(String type, String size, double weight) {
    this.type = type;
    this.size = size;
    this.weight = weight;
}
```

The default constructor simply prints a message.

---

### **Dog class constructors**

#### **Dog()**

```java
public Dog() {
    super("Mutt", "Big", 50);
}
```

This calls the **Animal constructor** with `"Mutt", "Big", 50"` â€” this is **super()** â†’ calling superclass constructor.

---

#### **Dog(String type, double weight)**

```java
public Dog(String type, double weight) {
    this(type, weight, "Perky", "Curled");
}
```

This calls **another constructor of the same class** â†’ `this()`
This is **constructor chaining** inside the same class.

---

#### **Dog(String type, double weight, String earShape, String tailShape)**

```java
super(type,
      weight < 15 ? "Small" : (weight < 35) ? "Medium" : "Big",
      weight);
```

Here:

* `size` is calculated using a **ternary operator**

  * weight < 15 â†’ "Small"
  * weight < 35 â†’ "Medium"
  * otherwise "Big"

This calls the parent constructor with calculated values.

---

# âœ… 3. Method Overriding (Runtime Polymorphism)

Dog overrides 3 methods:

### âœ” **makeNoise()**

```java
@Override
public void makeNoise() {
    System.out.println("Dog barks");
}
```

This REPLACES the parent classâ€™s version.

---

### âœ” **move()**

```java
@Override
public void move(String speed) {
    super.move(speed);
    System.out.println("Dog walk, run and wag their tail.");
}
```

This calls:

* Parent method â†’ `super.move(speed)`
* And then adds Dog-specific behavior

---

### âœ” **toString()**

```java
@Override
public String toString() {
    return "Dog{ ... }" + super.toString();
}
```

This adds Dog fields and then attaches Animal's `toString()` result.

---

# âœ… 4. Polymorphism in action

In `main()`:

```java
Animal animal = new Animal("Generic Animal", "Huge", 400);
doAnimalStuff(animal, "slow");
```

Here the reference type = `Animal`, object type = `Animal`

But next:

```java
Dog dog = new Dog();
doAnimalStuff(dog, "fast");
```

Even though `doAnimalStuff()` accepts:

```java
public static void doAnimalStuff(Animal animal, String speed)
```

You passed a **Dog object**.

This is **upcasting**:
`Dog` â†’ `Animal`

Inside the method:

```java
animal.makeNoise();
animal.move(speed);
```

Since `animal` is actually a **Dog instance**, the overridden Dog methods run.

This is **runtime polymorphism / dynamic binding**.

---

# âœ… 5. Output behavior (high-level)

For each object:

### `doAnimalStuff()` prints:

1. `toString()` â†’ Dog/Animal version depending on object
2. `makeNoise()` â†’ polymorphic
3. `move()` â†’ polymorphic
4. Prints separator

---

