
---

# ğŸ§µ Thread Synchronization in Java

## ğŸ”‘ What is Thread Synchronization?

**Thread Synchronization** is a mechanism that ensures:

* âœ… Only **one thread at a time** accesses a **shared resource**
* âŒ Prevents **data corruption**
* âŒ Avoids **race conditions**
* ğŸ›¡ï¸ Ensures **thread safety** in concurrent environments

ğŸ‘‰ In simple words:

> *Synchronization controls how multiple threads access critical sections of code.*

---

## âš ï¸ Why Synchronization is Needed (Race Condition Explained)

### Example: `count++`

Internally:

```java
count++  â‰¡  count = count + 1
```

This involves **three steps**:

1. Read `count`
2. Increment value
3. Write back to memory

### âŒ Without Synchronization

If **two threads** read `count = 2` at the same time:

* Thread T1 â†’ increments â†’ writes `3`
* Thread T2 â†’ increments â†’ writes `3`

ğŸš¨ **One increment is lost** â†’ **data corruption**

This is called a **Race Condition** ğŸƒâ€â™‚ï¸ğŸ’¥

---

## âœ… How Synchronization Fixes This

Synchronization ensures:

* Only **one thread enters the critical section**
* Other threads **wait outside**
* Lock is released after execution

---

# ğŸ› ï¸ Methods of Thread Synchronization in Java

Java provides synchronization using the **`synchronized` keyword**

There are **two main approaches**:

1. **Synchronized Method**
2. **Synchronized Block**

---

## 1ï¸âƒ£ Synchronized Method

### ğŸ“Œ Definition

When a method is declared `synchronized`:

* Only **one thread** can execute it at a time
* Lock is acquired on:

  * **Object instance** â†’ non-static method
  * **Class object** â†’ static method

### ğŸ§  Key Points

* Lock is acquired **before method execution**
* Lock is released **after method completes**
* Entire method becomes a **critical section**

---

### ğŸ’» Code: Synchronized Method Example

```java
public class CounterSyncMethod {

    private int count = 0;

    // Entire method is synchronized
    public synchronized void increment() {
        System.out.println("Start increment: " + Thread.currentThread().getName());

        count++;

        System.out.println("Counter value: " + count);
        System.out.println("End increment: " + Thread.currentThread().getName());
    }

    public int getCount() {
        return count;
    }

    public static void main(String[] args) throws InterruptedException {
        CounterSyncMethod counter = new CounterSyncMethod();

        Thread t1 = new Thread(counter::increment, "Thread-1");
        Thread t2 = new Thread(counter::increment, "Thread-2");
        Thread t3 = new Thread(counter::increment, "Thread-3");

        t1.start();
        t2.start();
        t3.start();

        t1.join();
        t2.join();
        t3.join();

        System.out.println("Final Counter Value: " + counter.getCount());
    }
}
```

---

### ğŸ§¾ Sample Output

```
Start increment: Thread-1
Counter value: 1
End increment: Thread-1

Start increment: Thread-3
Counter value: 2
End increment: Thread-3

Start increment: Thread-2
Counter value: 3
End increment: Thread-2

Final Counter Value: 3
```

âœ” Threads execute **one after another**
âœ” No data corruption
âœ” Order may vary, but correctness is guaranteed

---

### ğŸ”’ Important Concept: Object-Level Lock

* All threads call `counter.increment()`
* Lock is taken on **`counter` object**
* If **another object** exists:

  * Threads using that object can run **independently**

```java
Counter c1 = new Counter();
Counter c2 = new Counter();
```

ğŸ‘‰ `c1` and `c2` have **separate locks**

---

### âŒ Drawback of Synchronized Method

* Entire method is locked
* Even **non-critical code** waits
* â— Performance overhead

ğŸ‘‰ Solution: **Synchronized Block**

---

## 2ï¸âƒ£ Synchronized Block (Fine-Grained Control)

### ğŸ“Œ Definition

A synchronized block allows you to:

* Synchronize **only a specific portion** of code
* Explicitly choose **which objectâ€™s lock** to use

---

### ğŸ§  Why Use Synchronized Block?

* Only **critical section** is locked
* Non-critical code runs **concurrently**
* Better **performance**
* Required for `wait()`, `notify()`, `notifyAll()`

---

### ğŸ’» Code: Synchronized Block Example

```java
public class CounterSyncBlock {

    private int count = 0;
    private final Object lock = new Object();

    public void increment() {

        // Non-critical section
        System.out.println("Pre-processing: " + Thread.currentThread().getName());

        // Critical section
        synchronized (lock) {
            System.out.println("Start increment: " + Thread.currentThread().getName());
            count++;
            System.out.println("Counter value: " + count);
            System.out.println("End increment: " + Thread.currentThread().getName());
        }

        // Non-critical section
        System.out.println("Post-processing: " + Thread.currentThread().getName());
    }

    public int getCount() {
        return count;
    }

    public static void main(String[] args) throws InterruptedException {
        CounterSyncBlock counter = new CounterSyncBlock();

        Thread t1 = new Thread(counter::increment, "Thread-1");
        Thread t2 = new Thread(counter::increment, "Thread-2");
        Thread t3 = new Thread(counter::increment, "Thread-3");

        t1.start();
        t2.start();
        t3.start();

        t1.join();
        t2.join();
        t3.join();

        System.out.println("Final Counter Value: " + counter.getCount());
    }
}
```

---

### ğŸ§¾ Sample Output (Important Observation)

```
Pre-processing: Thread-2
Pre-processing: Thread-1

Start increment: Thread-2
Counter value: 1
End increment: Thread-2

Post-processing: Thread-2
Pre-processing: Thread-3

Start increment: Thread-1
Counter value: 2
End increment: Thread-1

Post-processing: Thread-1

Start increment: Thread-3
Counter value: 3
End increment: Thread-3

Post-processing: Thread-3

Final Counter Value: 3
```

### ğŸ” Whatâ€™s Happening?

* âœ… `Pre-processing` and `Post-processing` run **concurrently**
* ğŸ”’ Only the `synchronized(lock)` block runs **one thread at a time**
* âœ” Best balance between **safety & performance**

---

## ğŸ§  Key Differences: Method vs Block

| Feature                   | Synchronized Method       | Synchronized Block    |
| ------------------------- | ------------------------- | --------------------- |
| Granularity               | Coarse                    | Fine                  |
| Performance               | Lower                     | Higher                |
| Lock Control              | Implicit (`this` / class) | Explicit (any object) |
| wait/notify               | âŒ                         | âœ…                     |
| Preferred in real systems | âŒ                         | âœ…                     |

---

## ğŸ”¥ Real-World Usage

* **Producerâ€“Consumer**
* **Pub-Sub (Kafka-style)**
* **Thread-safe queues**
* **Shared cache / topic / buffer**
* Locking on:

  ```java
  synchronized(topic) { ... }
  ```

---

## âœ… Final Takeaways (Interview Gold)

* `synchronized` ensures **mutual exclusion**
* Lock depends on **object or class**
* Use **synchronized block** for performance
* Synchronization prevents **race conditions**
* Always synchronize **shared mutable state**

---
