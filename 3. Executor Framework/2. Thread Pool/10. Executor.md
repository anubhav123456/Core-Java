# Executor Framework in Java

---

## Why Executor Framework?

* Managing **a few threads** manually is easy, but it becomes **very complex** when dealing with **hundreds or thousands of threads**.
* The **Executor Framework** simplifies thread creation, execution, and lifecycle management.
* It promotes **separation of concerns**:

  * **Developer**: Defines *what* task to run (`Runnable`, `Callable`)
  * **Framework**: Decides *when, where, and how* to run the task using threads

---

## How Executor Works

1. Executor receives a **task** (Runnable / Callable)
2. It assigns the task to a **thread from the thread pool**
3. If no thread is available:

   * Task is placed into a **queue**
   * Task waits until a thread becomes free
4. If queue is full and new threads cannot be created, tasks may be **rejected**

---

## Core Interfaces in Executor Framework

### 1. Executor

* Base interface
* Only one method:

```java
void execute(Runnable command);
```

### 2. ExecutorService

* Extends `Executor`
* Adds lifecycle control and advanced task submission
* Supports:

  * `submit()`
  * `invokeAll()`
  * `invokeAny()`
  * `shutdown()`

### 3. ScheduledExecutorService

* Extends `ExecutorService`
* Used for **delayed** and **periodic** task execution

---

## ThreadPoolExecutor

* Concrete implementation of `ExecutorService`
* Uses a **pool of worker threads** internally
* Efficient reuse of threads instead of creating new ones repeatedly

---

## Types of Thread Pool Executors (Executors Utility Class)

### 1. Fixed Thread Pool

* Fixed number of threads
* Extra tasks wait in queue

```java
ExecutorService executor = Executors.newFixedThreadPool(5);
```

**Use case:** Stable number of concurrent tasks

---

### 2. Cached Thread Pool

* Creates new threads as needed
* Reuses idle threads
* **Risky** if tasks grow uncontrollably

```java
ExecutorService executor = Executors.newCachedThreadPool();
```

**Use case:** Short-lived asynchronous tasks

---

### 3. Scheduled Thread Pool

* Executes tasks after delay or periodically

```java
ExecutorService executor = Executors.newScheduledThreadPool(10);
```

**Use case:** Cron jobs, periodic background work

---

### 4. Single Thread Executor

* Only **one thread** executes all tasks sequentially

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
```

**Use case:** Maintaining task order

---

### 5. Work-Stealing Thread Pool

* Uses **ForkJoinPool** internally
* Optimized for multi-core processors

```java
ExecutorService executor = Executors.newWorkStealingPool(5);
```

**Use case:** CPU-intensive parallel tasks

---

## Ways to Delegate Tasks to ExecutorService

| Method              | Description                                            |
| ------------------- | ------------------------------------------------------ |
| `execute(Runnable)` | Fire-and-forget execution                              |
| `submit(Runnable)`  | Returns `Future<?>`                                    |
| `submit(Callable)`  | Returns `Future<T>`                                    |
| `invokeAny()`       | Returns result of **any one** callable                 |
| `invokeAll()`       | Executes **all** callables and returns list of Futures |

---

## Executor with Runnable – Example

### Code

```java
Runnable runnable = () -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    System.out.println(Thread.currentThread().getName()
            + " Finished executing at: " + LocalDateTime.now());
};

ExecutorService executor = Executors.newFixedThreadPool(10);

System.out.println("First Example - executing task with execute() method");
executor.execute(runnable);

System.out.println("Second Example - executing task with submit() method");
Future<String> result = executor.submit(runnable, "COMPLETED");

while (!result.isDone()) {
    System.out.println("The method return value: " + result.get());
}

executor.shutdown();
```

### Output

```
First Example - executing task with execute() method
Second Example - executing task with submit() method
pool-1-thread-1 Finished executing at: 2025-12-15T04:49:15
pool-1-thread-2 Finished executing at: 2025-12-15T04:49:15
The method return value: COMPLETED
```

### Key Points

* `execute()` → no return value
* `submit()` → returns `Future`
* `Future.get()` blocks until task completes

---

## Executor with Callable – Example

### Code

```java
Callable<String> callable = () -> {
    Thread.sleep(1000);
    return "Current Time is: " + LocalDateTime.now();
};

ExecutorService executor = Executors.newFixedThreadPool(1);
List<Callable<String>> taskList = Arrays.asList(callable, callable);

System.out.println("First example using invokeAll");
List<Future<String>> results = executor.invokeAll(taskList);

for (Future<String> result : results) {
    System.out.println(result);
    System.out.println(result.get());
}

System.out.println("Executing callable using submit");
Future<String> result = executor.submit(callable);

while (!result.isDone()) {
    System.out.println("The method return value: " + result.get());
}

executor.shutdown();
```

### Output

```
First example using invokeAll
FutureTask[Completed normally]
Current Time is: 2025-12-15T05:11:04
FutureTask[Completed normally]
Current Time is: 2025-12-15T05:11:05
Executing callable using submit
The method return value: Current Time is: 2025-12-15T05:11:06
```

### Key Points

* `Callable` **returns a value**
* `invokeAll()` waits for **all tasks** to complete
* `submit(callable)` returns a `Future<T>`

---

## Runnable vs Callable (Interview Favorite)

| Feature                  | Runnable | Callable |
| ------------------------ | -------- | -------- |
| Return value             | ❌ No     | ✅ Yes    |
| Throws checked exception | ❌ No     | ✅ Yes    |
| Method                   | `run()`  | `call()` |

---

## Important Best Practices

* Always call `shutdown()` or `shutdownNow()`
* Avoid `newCachedThreadPool()` in production unless controlled
* Prefer `ExecutorService` over manual thread creation
* Use bounded queues for better stability

---

## Interview One-Liner

> Executor Framework provides a high-level abstraction for managing thread execution, improving performance, scalability, and maintainability of concurrent applications.

---
