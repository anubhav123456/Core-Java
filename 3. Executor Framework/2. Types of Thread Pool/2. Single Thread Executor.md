
---

# Single Thread Executor in Java

## 1. What is an ExecutorService?

* `ExecutorService` is part of `java.util.concurrent`
* It **manages thread creation, execution, reuse, and destruction**
* Developers **submit tasks**, not threads
* Thread lifecycle is handled internally by the executor

---

## 2. Single Thread Executor

* Created using:

```java
ExecutorService service = Executors.newSingleThreadExecutor();
```

### Key Characteristics

* Uses **only one worker thread**
* Tasks are executed **sequentially**
* Maintains **FIFO order** (First-In-First-Out)
* Guarantees **task ordering**

---

## 3. Why Use Single Thread Executor?

* Cleaner alternative to manually creating threads
* No need to manage thread lifecycle (`start`, `join`, etc.)
* Ensures:

  * Sequential execution
  * Automatic thread recovery
  * Better resource management
---

## 4. Task Implementation

* Task implements `Runnable`
* Each task has a `taskId`
* `run()` method:

  * Prints task ID
  * Prints executing thread name
  * Sleeps for 500 ms to simulate work

### Example

```java
class Task implements Runnable {
    private final int taskId;

    public Task(int taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        System.out.println(
            "Task with ID " + taskId + 
            " being executed by Thread " + Thread.currentThread().getName()
        );
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

---

## 5. Submitting Tasks

* Tasks are submitted using:

```java
service.execute(new Task(i));
```

* No need to call `start()` on threads
* Executor decides **when and how** tasks run

---

## 6. Closing ExecutorService

### Why?

* Executor holds system resources
* Must be shut down properly

### Two Approaches

#### 1. Explicit Shutdown

```java
service.shutdown();
```

#### 2. Try-with-Resources (Recommended)

```java
try (ExecutorService service = Executors.newSingleThreadExecutor()) {
    // submit tasks
}
```

* Ensures automatic shutdown
* Prevents resource leaks
* Removes IDE warning

---

## 7. Complete Working Code

### ✅ `SingleThreadExecutorDemo.java`

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutorDemo {

    public static void main(String[] args) {

        // Creating a Single Thread Executor using try-with-resources
        try (ExecutorService service = Executors.newSingleThreadExecutor()) {

            // Submitting 5 tasks
            for (int i = 0; i < 5; i++) {
                service.execute(new Task(i));
            }
        }
        // ExecutorService is automatically shut down here
    }
}

class Task implements Runnable {

    private final int taskId;

    public Task(int taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        System.out.println(
            "Task with ID " + taskId +
            " being executed by Thread " +
            Thread.currentThread().getName()
        );

        try {
            Thread.sleep(500); // Simulating work
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```
---

## 8. Execution Flow

1. Main thread creates tasks
2. Tasks are submitted to ExecutorService
3. Tasks are placed in a **Task Queue**
4. Single worker thread:

   * Fetches task from queue
   * Executes it
   * Moves to next task

---

## 9. Output Behavior

```text
Task with ID 0 being executed by Thread pool-1-thread-1
Task with ID 1 being executed by Thread pool-1-thread-1
Task with ID 2 being executed by Thread pool-1-thread-1
Task with ID 3 being executed by Thread pool-1-thread-1
Task with ID 4 being executed by Thread pool-1-thread-1
```

### Observations

* Same thread executes all tasks
* Tasks execute **in submission order**
* No parallel execution

---

## 10. Under-the-Hood Working

* Thread Pool Size: **1**
* Components:

  * Main Thread
  * Task Queue
  * Single Worker Thread

### Internal Behavior

* Worker thread picks tasks from the queue
* Executes one task at a time
* If worker thread dies due to exception:

  * Executor **recreates the thread**
  * Remaining tasks continue execution

---

## 11. Advantages of Single Thread Executor

* Ensures **sequential execution**
* Eliminates thread management boilerplate
* Automatic thread recovery
* Cleaner and safer than manual thread creation
* Useful for:

  * Logging
  * File writing
  * Order-sensitive operations
  * Background serial processing

---

## 12. When to Use Single Thread Executor?

* ✔ Logging
* ✔ File I/O
* ✔ Database writes
* ✔ Order-sensitive tasks
* ✔ Background serial processing


## 13. Comparison with Manual Thread Creation

| Manual Threads         | ExecutorService          |
| ---------------------- | ------------------------ |
| Create thread manually | Executor manages threads |
| Create multiple Thread objects | Single reusable thread |
| Call `start()`         | Call `execute()`         |
| Hard to manage         | Clean & scalable         |
| Error-prone            | Fault-tolerant           |
| No fault recovery              | Automatic recovery     |

---

## 14. Key Takeaways

* Single Thread Executor runs tasks **one by one**
* Order of execution is guaranteed
* Thread lifecycle is fully managed
* Best choice when **task order matters**

---


## 15. One-Line Summary

> **Single Thread Executor guarantees sequential execution using one managed thread, making concurrent programming safer and cleaner.**

---

