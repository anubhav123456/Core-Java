
---

# Callable and Future in Java — Notes

## 1. Problem with Runnable

* `Runnable` interface has only one method:

  ```java
  void run();
  ```
* Since `run()` returns `void`, **we cannot return any value from a thread**.
* If we want a thread to **return a result**, `Runnable` is not sufficient.

---

## 2. Solution: Callable Interface

* Java provides another interface: **`Callable`**
* Key differences:

| Runnable                            | Callable                     |
| ----------------------------------- | ---------------------------- |
| `run()` returns `void`              | `call()` returns a value     |
| Cannot throw checked exceptions     | Can throw checked exceptions |
| Used with `execute()` or `submit()` | Must be used with `submit()` |

---

## 3. Basic Callable Example (Returning a Value)

### Code

```java
import java.util.concurrent.*;

public class CallableDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        try (ExecutorService executorService = Executors.newFixedThreadPool(2)) {

            Future<Integer> result = executorService.submit(new ReturnValueTask());

            // Blocks until result is available
            System.out.println(result.get());

            System.out.println("Main thread execution completed!");
        }
    }
}

class ReturnValueTask implements Callable<Integer> {
    @Override
    public Integer call() {
        return 12;
    }
}
```

### Output

```
12
Main thread execution completed!
```

### Explanation

* `submit()` returns a **Future**
* `Future<Integer>` acts as a **placeholder** for the result
* `future.get()` blocks the main thread until the value is available

---

## 4. Understanding Future.get() Blocking Behavior

* `Future.get()` is a **blocking call**
* If the task has **not completed**, the main thread **waits**
* Once the result is ready, execution resumes

---

## 5. Demonstrating Blocking with Thread.sleep()

### Code

```java
class ReturnValueTask implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        Thread.sleep(5000); // simulate delay
        return 12;
    }
}
```

### Execution Flow

1. Callable sleeps for 5 seconds
2. `future.get()` blocks the main thread
3. After 5 seconds, result is returned

### Output (after 5 seconds)

```
12
Main thread execution completed!
```

---

## 6. Using Timeout with Future.get()

To avoid indefinite blocking, use the overloaded `get()` method.

### Code

```java
System.out.println(result.get(6, TimeUnit.SECONDS));
System.out.println("Main thread execution completed!");
```

### Behavior

* Waits **up to 6 seconds**
* If result arrives → returns value
* If not → throws `TimeoutException`

### Output

```
12
Main thread execution completed!
```

---

## 7. TimeoutException Example

### Code

```java
System.out.println(result.get(1, TimeUnit.SECONDS));
```

(Callable still sleeps for 5 seconds)

### Output

```
Exception in thread "main" java.util.concurrent.TimeoutException
```

### Key Point

* Main thread does **not wait indefinitely**
* Execution stops unless exception is handled

---

## 8. Cancelling a Future

### Code

```java
import java.util.concurrent.*;

public class CallableDemo {
    public static void main(String[] args) throws Exception {

        try (ExecutorService executorService = Executors.newFixedThreadPool(2)) {

            Future<Integer> result = executorService.submit(new ReturnValueTask());

            result.cancel(true); // may interrupt if running

            boolean cancelled = result.isCancelled();
            boolean done = result.isDone();

            System.out.println("Cancelled: " + cancelled);
            System.out.println("Done: " + done);

            System.out.println(result.get(6, TimeUnit.SECONDS));
        }
    }
}

class ReturnValueTask implements Callable<Integer> {
    @Override
    public Integer call() {
        return 12;
    }
}
```

### Output

```
Cancelled: true
Done: true
Exception in thread "main" java.util.concurrent.CancellationException
```

---

## 9. Important Future Methods

### 1. `future.get()`

* Retrieves result
* **Blocking call**

### 2. `future.get(timeout, unit)`

* Waits for a limited time
* Throws `TimeoutException`

### 3. `future.cancel(boolean mayInterruptIfRunning)`

* `true` → may interrupt running thread
* `false` → does not interrupt

### 4. `future.isCancelled()`

* Returns `true` if task was cancelled

### 5. `future.isDone()`

* Returns `true` if:

  * Task completed successfully
  * Task was cancelled
  * Task ended with exception

---

## 10. Key Interview Takeaways

* Use **Runnable** when:

  * No return value needed
  * Fire-and-forget tasks

* Use **Callable** when:

  * Return value is required
  * Exception handling is important

* `Future`:

  * Acts as a placeholder
  * `get()` is blocking
  * Supports cancellation and timeout

---

## 11. Summary

* Runnable ❌ cannot return values
* Callable ✅ can return values
* Callable must be used with `submit()`
* `Future` represents pending result
* `Future.get()` blocks main thread
* Timeout & cancellation give control over execution

---

