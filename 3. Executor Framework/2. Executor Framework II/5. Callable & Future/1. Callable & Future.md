## Callable & Future in Java (Executor Framework)

### 1. Callable Interface

* `Callable` represents a task that **returns a result**.
* It is similar to `Runnable`, but:

  * `Runnable.run()` → returns **void**
  * `Callable.call()` → returns a **value** and can throw **checked exceptions**
* Mainly used when we want **computed results or status** back from a thread.

**Syntax:**

```java
Callable<Integer> task = () -> {
    // computation
    return result;
};
```

---

### 2. Future Interface

* `Future` represents the **result of an asynchronous computation**.
* It acts as a placeholder for the result that will be available **in the future**, once the `Callable` finishes execution.
* The main thread uses `Future` to:

  * Check task completion
  * Retrieve result
  * Cancel task execution

---

### 3. Important Methods of Future

| Method                         | Description                                                       |
| ------------------------------ | ----------------------------------------------------------------- |
| `cancel(boolean mayInterrupt)` | Cancels the task. If `mayInterrupt=true`, interrupts running task |
| `get()`                        | Returns result. Blocks if task is not completed                   |
| `isDone()`                     | Returns `true` if task is completed                               |

---

### 4. Example: Sum of Numbers using Callable & Future

#### Problem Statement

* An array of numbers from **0 to 5000**
* Split the array into **two halves**
* Compute sum of each half using **two Callable tasks**
* Combine results in the main thread

---

### 5. Code Example

```java
package com.modernjava.threading;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.IntStream;

public class SumOfNumbersUsingCallable {
    
    public static int sum = 0;
    public static int[] array = IntStream.rangeClosed(0, 5000).toArray();
    public static int total = IntStream.rangeClosed(0, 5000).sum();

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        
        Callable<Integer> callable1 = () -> {
            int sum = 0;
            for (int i = 0; i < array.length / 2; i++) {
                sum = sum + array[i];
            }
            return sum;
        };
        
        Callable<Integer> callable2 = () -> {
            int sum = 0;
            for (int i = array.length / 2; i < array.length; i++) {
                sum = sum + array[i];
            }
            return sum;
        };
        
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        List<Callable<Integer>> tasksList = Arrays.asList(callable1, callable2);
        List<Future<Integer>> results = executorService.invokeAll(tasksList);
        
        int k = 0;
        for (Future<Integer> result : results) {
            sum = sum + result.get();
            System.out.println("Sum " + ++k + " is: " + result.get());
        }
        
        System.out.println("Sum from the threads is: " + sum);
        System.out.println("Correct sum is: " + total);
        
        executorService.shutdown();
    }
}
```

---

### 6. Output

```text
Sum 1 is: 3126250
Sum 2 is: 9378750
Sum from the threads is: 12505000
Correct sum is: 12505000
```

---

### 7. Key Takeaways (Interview Ready)

* `Callable` is preferred over `Runnable` when **return value is needed**
* `Future.get()` is a **blocking call**
* `invokeAll()` submits multiple tasks and returns a list of `Future` objects
* Executor framework **manages threads efficiently**
* Useful for **parallel computation & performance optimization**

---

### 8. When to Use Callable & Future

* Parallel calculations (sum, aggregation, report generation)
* Background tasks with results
* When you need **task status + result control**

---

