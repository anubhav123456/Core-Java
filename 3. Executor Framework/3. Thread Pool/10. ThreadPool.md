
---

# ExecutorService ‚Äì Essential Task Submission Methods

`ExecutorService` is the **core interface** of Java‚Äôs concurrency framework.
It manages a pool of threads and provides multiple ways to **submit tasks** for execution.

The most commonly used **task submission methods** are:

1. `execute()`
2. `submit()`
3. `invokeAll()`

---

## 1Ô∏è‚É£ `execute(Runnable task)` ‚Äì Fire & Forget

### Purpose

* Submits a **Runnable** task.
* **No result tracking**.
* Best for **simple background tasks**.

### Key Characteristics

‚úÖ Task runs asynchronously
‚úÖ Very lightweight
‚ùå No result returned
‚ùå Exceptions are **lost** unless manually logged
‚ùå No visibility into success/failure

---

### Code Example

```java
ExecutorService executor = Executors.newFixedThreadPool(1);

executor.execute(() -> {
    System.out.println("Task executed");
});

executor.shutdown();
```

---

### Execution Details

#### ‚úÖ Success

* Task runs in a background thread.
* No blocking.
* Ideal for logging, metrics, cleanup jobs.

#### ‚ö†Ô∏è Failure Scenarios

* If task throws an exception ‚Üí **exception is swallowed**
* No retry mechanism
* No way to know task status
* Machine crash ‚Üí task is lost

üìå **Use when:**
You truly don‚Äôt care about the outcome.

---

## 2Ô∏è‚É£ `submit()` ‚Äì Result-Oriented Execution

### Method Signatures

```java
Future<?> submit(Runnable task)
<T> Future<T> submit(Callable<T> task)
```

### Purpose

* Submits a task and returns a **Future**.
* Supports both `Runnable` and `Callable`.

---

### Code Example (Callable)

```java
ExecutorService executor = Executors.newSingleThreadExecutor();

Future<String> future = executor.submit(() -> {
    return "Hello from Callable";
});

try {
    String result = future.get(); // blocks
    System.out.println(result);
} catch (Exception e) {
    e.printStackTrace();
}

executor.shutdown();
```

---

### Execution Details

#### ‚úÖ Success

* Returns a `Future`
* `future.get()` retrieves result
* You can check:

  * `future.isDone()`
  * `future.isCancelled()`

#### ‚ö†Ô∏è Failure Scenarios

* If task throws exception ‚Üí
  `future.get()` throws **ExecutionException**
* Blocking call ‚Üí may impact performance
* Machine crash ‚Üí in-flight tasks lost

üìå **Use when:**
You need **result, exception handling, or task status**.

---

## 3Ô∏è‚É£ `invokeAll()` ‚Äì Bulk Parallel Execution

### Method Signature

```java
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
```

### Purpose

* Executes **multiple tasks in parallel**
* **Blocks until all tasks complete**
* Returns a list of `Future`s

---

### Code Example

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Collection<Callable<String>> tasks = Arrays.asList(
    () -> "Task 1",
    () -> "Task 2"
);

try {
    List<Future<String>> results = executor.invokeAll(tasks);

    for (Future<String> future : results) {
        System.out.println(future.get());
    }
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}

executor.shutdown();
```

---

### Execution Details

#### ‚úÖ Success

* All tasks run concurrently
* Waits for **every task** to finish
* Each task has its own `Future`

#### ‚ö†Ô∏è Failure Scenarios

* One task failure does **not stop others**
* Calling `future.get()` on failed task throws exception
* Executor shutdown mid-way ‚Üí remaining tasks interrupted
* Machine crash ‚Üí all tasks lost

üìå **Use when:**
You want **parallel batch processing** and need results for all tasks.

---

## 4Ô∏è‚É£ `invokeAll()` with Timeout

### Overloaded Method

```java
<T> List<Future<T>> invokeAll(
    Collection<? extends Callable<T>> tasks,
    long timeout,
    TimeUnit unit
)
```

### Purpose

* Limits maximum waiting time
* Tasks not completed within timeout are **cancelled**

---

### Code Example

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Collection<Callable<String>> tasks = Arrays.asList(
    () -> {
        Thread.sleep(500);
        return "Fast Task";
    },
    () -> {
        Thread.sleep(2000);
        return "Slow Task";
    }
);

try {
    List<Future<String>> results =
        executor.invokeAll(tasks, 1, TimeUnit.SECONDS);

    for (Future<String> future : results) {
        if (future.isCancelled()) {
            System.out.println("Task was cancelled");
        } else {
            System.out.println(future.get());
        }
    }
} catch (Exception e) {
    e.printStackTrace();
}

executor.shutdown();
```

---

### Behavior

* Tasks exceeding timeout ‚Üí **cancelled**
* Completed tasks ‚Üí results available
* Prevents infinite blocking

üìå **Use when:**
You need **time-bound parallel execution**.

---

## üîë Summary Table

| Method               | Returns        | Blocks?     | Exception Handling | Best Use Case           |
| -------------------- | -------------- | ----------- | ------------------ | ----------------------- |
| `execute()`          | Nothing        | ‚ùå           | ‚ùå Lost             | Fire-and-forget         |
| `submit()`           | `Future`       | Optional    | ‚úÖ via `get()`      | Result-based tasks      |
| `invokeAll()`        | `List<Future>` | ‚úÖ           | Partial            | Batch parallel jobs     |
| `invokeAll(timeout)` | `List<Future>` | ‚úÖ (bounded) | Partial            | Time-limited batch jobs |

---
