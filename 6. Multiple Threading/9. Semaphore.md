## Semaphore in Java

### What is a Semaphore?

* `Semaphore` is a synchronization utility provided in **`java.util.concurrent`** package.
* It is used to **control access to a shared resource** by multiple threads.
* Semaphore works using a **permit counter**.

### Key Concepts

* Semaphore maintains a fixed number of **permits**.
* A thread must acquire a permit before accessing the resource.
* If no permits are available, the thread **blocks** until a permit is released.

### Working of Semaphore

1. If the permit count is **greater than zero**, a thread acquires a permit and the count is **decremented**.
2. If the permit count is **zero**, the thread is **blocked** until a permit becomes available.
3. When a thread finishes using the resource, it **releases** the permit, increasing the count.
4. A waiting thread can then acquire the released permit and continue execution.

### Common Use Cases

* Limiting the number of **database connections**
* Restricting access to **thread pools**
* Implementing **bounded collections**
* Rate limiting

---

## Example: Bounded Collection using Semaphore

### Explanation

* We restrict the size of a collection using a `Semaphore`.
* Semaphore limit = maximum allowed elements.
* `add()` acquires a permit before inserting.
* `remove()` releases a permit after deleting.

---

### Code: BoundCollection Class

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Semaphore;

public class BoundCollection {
    private final Semaphore semaphore;
    private List<Integer> arrayList;

    public BoundCollection(int limit) {
        semaphore = new Semaphore(limit);
        this.arrayList = Collections.synchronizedList(new ArrayList<Integer>());
    }

    public boolean add(Integer i) throws InterruptedException {
        boolean added = false;
        semaphore.acquire(); // acquire permit
        added = arrayList.add(i);
        if (!added) {
            semaphore.release(); // release if add fails
        }
        return added;
    }

    public boolean remove(Integer i) {
        boolean removed = arrayList.remove(i);
        if (removed) {
            semaphore.release(); // release permit after removal
        }
        return removed;
    }
}
```

---

### Code: Main Class

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        final BoundCollection boundCollection = new BoundCollection(10);

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                try {
                    if (boundCollection.add(i)) {
                        System.out.println(Thread.currentThread().getName() + " adding value " + i);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                if (boundCollection.remove(i)) {
                    System.out.println(Thread.currentThread().getName() + " removing value " + i);
                }
            }
        });

        thread1.start();
        Thread.sleep(1000); // ensure add thread starts first
        thread2.start();
    }
}
```

---

### Output

```text
Thread-0 adding value 0
Thread-0 adding value 1
Thread-0 adding value 2
Thread-0 adding value 3
Thread-0 adding value 4
Thread-0 adding value 5
Thread-0 adding value 6
Thread-0 adding value 7
Thread-0 adding value 8
Thread-0 adding value 9
Thread-0 adding value 10
Thread-1 removing value 0
Thread-1 removing value 1
Thread-0 adding value 11
Thread-1 removing value 2
Thread-0 adding value 12
Thread-0 adding value 13
Thread-1 removing value 3
Thread-1 removing value 4
Thread-0 adding value 14
Thread-0 adding value 15
Thread-1 removing value 5
Thread-1 removing value 6
Thread-0 adding value 16
Thread-0 adding value 17
Thread-1 removing value 7
Thread-1 removing value 8
Thread-0 adding value 18
Thread-1 removing value 9
Thread-0 adding value 19
Thread-1 removing value 10
Thread-1 removing value 11
Thread-1 removing value 12
Thread-1 removing value 13
Thread-1 removing value 14
Thread-1 removing value 15
Thread-1 removing value 16
Thread-1 removing value 17
Thread-1 removing value 18
Thread-1 removing value 19
```

---

### Key Takeaways

* Semaphore controls **concurrent access**, not mutual exclusion.
* It is ideal when you want **N threads** to access a resource simultaneously.
* Always ensure permits are **released properly** to avoid deadlocks.

---

### Interview Tip

> Semaphore â‰  synchronized

* `synchronized` allows **only one thread**
* Semaphore allows **multiple threads up to a limit**

---
