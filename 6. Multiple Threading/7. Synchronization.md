# Java Synchronization Notes

## What is Java Synchronization?

Java synchronization is a mechanism to **control access of multiple threads to shared resources**. It ensures that only one thread can execute a critical section of code (or access a shared object) at a time.

### Why Use Synchronization?
1. **Prevent thread interference** – Multiple threads modifying the same data simultaneously.
2. **Avoid consistency/maintain data integrity issues** – Ensures consistent state of shared resources.

## Types of Thread Synchronization

1. **Mutual Exclusion** (Ensures only one thread accesses the resource at a time)
   - Synchronized method
   - Synchronized block
   - Static synchronization

2. **Cooperation (Inter-thread communication)**
   - `wait()`
   - `notify()`
   - `notifyAll()`

## Mutual Exclusion

Synchronization uses an **intrinsic lock (monitor lock)** associated with every object in Java.

- A thread must acquire the object's lock before entering a synchronized block/method.
- Only one thread can hold the lock at a time.

### Ways to Apply Synchronization

1. **Synchronized Method**
2. **Synchronized Block**
3. **Static Synchronization**

### Intrinsic Lock Rules

| Type                          | Lock Object              | Scope                                      |
|-------------------------------|--------------------------|--------------------------------------------|
| Synchronized instance method  | `this` (instance)        | Per instance – different objects have different locks |
| Synchronized static method    | `.class` object          | Class-level – same for all instances       |
| Synchronized block            | Any object specified     | Flexible – can lock on `this`, class, or other object |

---

## Example 1: Race Condition Without Synchronization

### Problem Code

```java
public class FastFoodRestaurant {
    private String lastClientName;
    private int numberOfBurgersSold;

    public void buyBurger(String clientName) {
        alongRunningProcess(); // Simulates time before update
        this.lastClientName = clientName;
        numberOfBurgersSold++;
        System.out.println(clientName + " bought a burger.");
    }

    private void alongRunningProcess() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public String getLastClientName() {
        return lastClientName;
    }

    public int getNumberOfBurgersSold() {
        return numberOfBurgersSold;
    }
}
```

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        FastFoodRestaurant restaurant = new FastFoodRestaurant();

        Thread t1 = new Thread(() -> restaurant.buyBurger("Mike"));
        Thread t2 = new Thread(() -> restaurant.buyBurger("Bill"));
        Thread t3 = new Thread(() -> restaurant.buyBurger("Jack"));
        Thread t4 = new Thread(() -> restaurant.buyBurger("Kristie"));

        t1.start(); t2.start(); t3.start(); t4.start();
        t1.join(); t2.join(); t3.join(); t4.join();

        System.out.println("Total burgers sold: " + restaurant.getNumberOfBurgersSold());
        System.out.println("Last client: " + restaurant.getLastClientName());

        long diff = System.currentTimeMillis() - startTime;
        System.out.println("Execution time: " + diff + " ms");
    }
}
```

### Output (Example – results vary due to race condition)

```
Mike bought a burger.
Kristie bought a burger.
Jack bought a burger.
Bill bought a burger.
Total burgers sold: 2
Last client: Mike
Execution time: 2018 ms
```

**Issue**: Only 2 burgers counted instead of 4 → **Race condition**.

---

## Fix 1: Synchronized Method

```java
public synchronized void buyBurger(String clientName) {  // Add synchronized
    alongRunningProcess();
    this.lastClientName = clientName;
    numberOfBurgersSold++;
    System.out.println(clientName + " bought a burger.");
}
```

### Output

```
Mike bought a burger.
Kristie bought a burger.
Jack bought a burger.
Bill bought a burger.
Total burgers sold: 4
Last client: Bill
Execution time: 8049 ms
```

**Correct count**, but **slow** (~8 seconds) because entire method (including sleep) is synchronized.

---

## Fix 2: Synchronized Block (Full)

```java
public void buyBurger(String clientName) {
    synchronized (this) {
        alongRunningProcess();
        this.lastClientName = clientName;
        numberOfBurgersSold++;
        System.out.println(clientName + " bought a burger.");
    }
}
```

### Output

Same as synchronized method:
- Correct count: 4
- Slow execution: ~8059 ms

Still synchronizes the long-running sleep.

---

## Optimization: Minimal Synchronized Block

```java
public void buyBurger(String clientName) {
    alongRunningProcess(); // Outside sync
    synchronized (this) {
        this.lastClientName = clientName;
        numberOfBurgersSold++;
    }
    System.out.println(clientName + " bought a burger."); // Outside sync
}
```

### Output

```
Kristie bought a burger.
Bill bought a burger.
Jack bought a burger.
Mike bought a burger.
Total burgers sold: 4
Last client: Bill
Execution time: 2027 ms
```

**Best performance**: Only critical section is synchronized → threads can run `alongRunningProcess()` concurrently.

---

## Inter-Thread Communication: wait(), notify(), notifyAll()

These methods **must be called inside a synchronized block/method** on the same object, otherwise `IllegalMonitorStateException` is thrown.

- `wait()` → Releases the lock and puts thread in waiting state.
- `notify()` → Wakes up **one** waiting thread.
- `notifyAll()` → Wakes up **all** waiting threads.

### Example: Course Completion Notification

```java
public class Course {
    private String title;
    private boolean completed;

    public Course(String title) {
        this.title = title;
    }

    public String getTitle() { return title; }
    public boolean isCompleted() { return completed; }
    public void setCompleted(boolean completed) { this.completed = completed; }
}
```

### Case 1: Using `notify()` – Only one student wakes up

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        final Course course = new Course("Java");

        Thread student1 = new Thread(() -> {
            synchronized (course) {
                System.out.println(Thread.currentThread().getName() + " waiting for " + course.getTitle());
                try { course.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName() + " completed " + course.getTitle());
            }
        }, "Kristie");

        Thread student2 = new Thread(() -> {
            synchronized (course) {
                System.out.println(Thread.currentThread().getName() + " waiting for " + course.getTitle());
                try { course.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName() + " completed " + course.getTitle());
            }
        }, "Mike");

        Thread teacher = new Thread(() -> {
            synchronized (course) {
                System.out.println(Thread.currentThread().getName() + " starting " + course.getTitle());
                try { Thread.sleep(4000); course.notify(); } // Only one student wakes
                catch (InterruptedException e) { e.printStackTrace(); }
            }
        }, "Jack");

        student1.start();
        student2.start();
        teacher.start();
    }
}
```

### Output

```
Kristie waiting for Java
Mike waiting for Java
Jack starting Java
Kristie completed Java
```

Only **Kristie** wakes up (Mike remains waiting).

---

### Case 2: Using `notifyAll()` – All students wake up

Change in teacher thread:

```java
course.notifyAll(); // Instead of notify()
```

### Output

```
Kristie waiting for Java
Mike waiting for Java
Jack starting Java
Kristie completed Java
Mike completed Java
```

Both students complete the course.

---

### Case 3: Chaining Notification (Students notify each other)

Students call `notify()` after completing:

```java
Thread student1 = new Thread(() -> {
    synchronized (course) {
        System.out.println(Thread.currentThread().getName() + " waiting...");
        try { course.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println(Thread.currentThread().getName() + " completed...");
        course.notify(); // Wake next
    }
}, "Kristie");

// student2 also calls course.notify() after completing
```

Teacher calls `notify()` once.

### Output

```
Kristie waiting for Java
Mike waiting for Java
Jack starting Java
Kristie completed Java
Mike completed Java
```

Chain works: Teacher → Kristie → Mike

---

## Summary Table

| Technique                  | Use Case                                      | Performance Impact                     | Scope                  |
|----------------------------|-----------------------------------------------|----------------------------------------|------------------------|
| No synchronization         | Single-threaded or immutable data             | Fastest                                | N/A                    |
| Synchronized method        | Entire method needs protection                | Slow if method has long non-critical work | Instance or class     |
| Synchronized block         | Only critical section needs protection        | Better performance                     | Flexible (any object) |
| Minimal synchronized block | Best for performance when non-critical work exists | Optimal                           | Recommended            |
| wait()/notify()/notifyAll()| Inter-thread communication (producer-consumer)| Required for coordination              | Must be in synchronized context |

**Best Practice**: Synchronize only the smallest necessary portion of code. Use `notifyAll()` in most real-world cases to avoid missed notifications.