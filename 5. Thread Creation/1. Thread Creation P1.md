
---

# Thread Creation in Java

Java provides multiple ways to create threads. The four most commonly used approaches are:

1. Extending the `Thread` class
2. Implementing the `Runnable` interface
3. Using Anonymous Inner Class
4. Using Lambda Expression

---

## 1. Creating a Thread by Extending the `Thread` Class

### Code

```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

### Usage

```java
MyThread thread1 = new MyThread();
thread1.start();
```

### Pros

âœ… Simple and easy to understand
âœ… Direct access to `Thread` methods (`getName()`, `getPriority()` etc.)
âœ… Good for learning multithreading basics

### Cons

âŒ **Java does not support multiple inheritance**, so you cannot extend any other class
âŒ Tight coupling between task logic and thread
âŒ Not recommended for large-scale or enterprise applications

---

## 2. Creating a Thread by Implementing `Runnable` Interface

### Code

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

### Usage

```java
MyRunnable runnable = new MyRunnable();
Thread thread2 = new Thread(runnable);
thread2.start();
```

### Pros

âœ… Supports **multiple inheritance** (can extend another class)
âœ… Better **separation of concern** (task â‰  thread)
âœ… Recommended approach in real-world applications
âœ… Compatible with Executor Framework

### Cons

âŒ Slightly more verbose than extending `Thread`
âŒ Cannot directly access Thread methods without `Thread.currentThread()`

---

## 3. Creating a Thread Using Anonymous Inner Class

### Code

```java
Thread thread3 = new Thread(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
});
```

### Usage

```java
thread3.start();
```

### Pros

âœ… No need to create a separate class
âœ… Useful for **one-time tasks**
âœ… Reduces boilerplate code

### Cons

âŒ Readability decreases for complex logic
âŒ Harder to debug
âŒ Cannot reuse the logic

---

## 4. Creating a Thread Using Lambda Expression (Java 8+)

### Code

```java
Thread thread4 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println(Thread.currentThread().getName() + " is running " + i);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            System.out.println("Thread interrupted.");
        }
    }
});
```

### Usage

```java
thread4.start();
```

### Pros

âœ… **Shortest and cleanest syntax**
âœ… Best readability
âœ… Ideal for small tasks
âœ… Works perfectly with functional programming

### Cons

âŒ Not suitable for very complex logic
âŒ Can reduce clarity if overused

---

## Complete Working Program (All 4 Methods Together)

```java
public class Main {
    public static void main(String[] args) {

        MyThread thread1 = new MyThread();

        MyRunnable runnable = new MyRunnable();
        Thread thread2 = new Thread(runnable);

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println(Thread.currentThread().getName() + " is running " + i);
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted.");
                    }
                }
            }
        });

        Thread thread4 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        });

        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
    }
}
```

---

## Output (Sample)

```
Thread-3 is running 0
Thread-0 is running 0
Thread-1 is running 0
Thread-2 is running 0
Thread-0 is running 1
Thread-2 is running 1
Thread-3 is running 1
Thread-1 is running 1
Thread-0 is running 2
Thread-1 is running 2
Thread-2 is running 2
Thread-3 is running 2
Thread-3 is running 3
Thread-0 is running 3
Thread-2 is running 3
Thread-1 is running 3
Thread-1 is running 4
Thread-3 is running 4
Thread-2 is running 4
Thread-0 is running 4
```

### Why Output Order Changes?

* Thread scheduling is **handled by JVM + OS**
* No guaranteed execution order
* `Thread.sleep()` pauses only the **current thread**

---

## Quick Interview Comparison Table

| Method              | Recommended? | Use Case            |
| ------------------- | ------------ | ------------------- |
| Extends Thread      | âŒ No         | Learning basics     |
| Implements Runnable | âœ… Yes        | Real applications   |
| Anonymous Class     | âš ï¸ Sometimes | One-time tasks      |
| Lambda              | âœ… Best       | Short & clean tasks |

---

### â­ What is the difference between `start()` and `run()` methods?

> *"The `start()` method begins thread execution and calls the `run()` method, while the `run()` method simply contains the code to be executed. Directly calling `run()` won't create a new thread; it will execute in the current thread."*

---

### â­ Can we call the start() method twice on the same Thread object?

> *"A thread in Java has a strict lifecycle. Once `start()` is called, the thread moves out of the NEW state and becomes associated with a native OS thread. Java does not allow restarting the same thread because native threads and call stacks cannot be reused. Therefore, calling `start()` twice throws an IllegalThreadStateException."*


After a thread finishes execution:

* The native OS thread âŒ gets destroyed
* The call stack âŒ gets freed
* CPU resources âŒ get released

Now, if the JVM allows:

```java
t.start(); // again
```

Then the JVM would have to:

* âŒ Revive the old OS thread (not possible)
* âŒ Restore the old call stack (already destroyed)

ğŸ‘‰ OS threads are dead after termination; they do not become zombies ğŸ˜„

---