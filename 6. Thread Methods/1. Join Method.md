
---

# ðŸ“˜ Java `join()` Method â€“ Complete Notes

## 1ï¸âƒ£ Problem Without `join()`

### Code

```java
public class Main {
    public static void main(String[] args) {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        }, "One");

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        }, "Two");

        thread1.start();
        thread2.start();

        System.out.println("Done executing the threads");
    }
}
```

### Output (one possible order)

```
Done executing the threads
One is running 0
Two is running 0
Two is running 1
One is running 1
One is running 2
Two is running 2
One is running 3
Two is running 3
One is running 4
Two is running 4
```

---

## 2ï¸âƒ£ Why Is `"Done executing the threads"` Printed First?

### Key Points

* `main()` runs on the **main thread**
* `thread1.start()` and `thread2.start()` only move threads to the **Runnable state**
* Threads run **independently**
* The **main thread does NOT wait** for other threads by default
* So it immediately prints:

  ```java
  System.out.println("Done executing the threads");
  ```


---

## 3ï¸âƒ£ What Is the `join()` Method?

### Definition

`join()` tells the **calling thread** (main thread here) to:

> â€œWait until this thread finishes executionâ€

### In simple words:

* Parent thread waits for child thread
* Execution becomes **sequential instead of parallel**

---

## 4ï¸âƒ£ Using `join()` to Wait for Threads

### Code (Using `join()` on both threads)

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        }, "One");

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        }, "Two");

        thread1.start();
        thread2.start();

        thread1.join(); // main waits for thread1
        thread2.join(); // main waits for thread2

        System.out.println("Done executing the threads");
    }
}
```

### Output

```
Two is running 0
One is running 0
One is running 1
Two is running 1
Two is running 2
One is running 2
Two is running 3
One is running 3
One is running 4
Two is running 4
Done executing the threads
```

âœ… `"Done executing the threads"` is printed **only after both threads finish**

---

## 5ï¸âƒ£ Adding Messages Before and After Threads

### Code

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {

        System.out.println("Before executing the threads");

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                System.out.println("Thread One running " + i);
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                System.out.println("Thread Two running " + i);
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("Done executing the threads");
    }
}
```

### Output

```
Before executing the threads
Thread One running 0
Thread Two running 0
Thread One running 1
Thread Two running 1
Thread One running 2
Thread Two running 2
Done executing the threads
```

---

## 6ï¸âƒ£ Important Theoretical Concepts

### ðŸ”¹ Main Thread

* Created automatically by JVM
* Acts as the **parent thread**
* Spawns child threads

### ðŸ”¹ Thread Execution (Without `join`)

* Threads run **independently**
* No guarantee of order
* Main thread does NOT wait

### ðŸ”¹ Thread Execution (With `join`)

* Parent thread **waits**
* Child thread finishes first
* Execution becomes controlled

---

## 7ï¸âƒ£ How `join()` Works Internally (Conceptual)

```text
Main Thread
   |
   |----> Thread-1 (join)
   |        |
   |        |----> completes
   |
   |----> Thread-2 (join)
   |        |
   |        |----> completes
   |
Main thread resumes
```

---

## 8ï¸âƒ£ Interview-Friendly Definition

> **`join()` method causes the currently executing thread to wait until the thread on which join is called completes its execution.**

---
