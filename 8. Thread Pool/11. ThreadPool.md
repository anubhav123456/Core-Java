
---

# ExecutorService â€“ Essential Lifecycle & Scheduling âš™ï¸â°

## 1. ExecutorService Lifecycle Management

Lifecycle management is **critical** because thread pools are system resources.
If you donâ€™t shut them down properly â†’ **memory leaks, JVM not exiting, resource exhaustion**.

### ðŸ”¹ `shutdown()`

**Purpose:** Graceful shutdown

```java
void shutdown();
```

* Stops accepting new tasks
* Allows already submitted tasks to complete
* Threads terminate **after** task completion

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> System.out.println("Task running"));
executor.shutdown(); // graceful shutdown
```

âœ… **Use when:**

* You want tasks to complete safely
* Application is finishing normally

---

### ðŸ”¹ `shutdownNow()`

**Purpose:** Forceful / immediate shutdown

```java
List<Runnable> shutdownNow();
```

* Attempts to stop all running tasks
* Interrupts threads
* Returns tasks that were **submitted but never started**

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        System.out.println("Task interrupted");
    }
});

List<Runnable> pendingTasks = executor.shutdownNow();
System.out.println("Pending tasks: " + pendingTasks.size());
```

âš ï¸ **Important Notes:**

* Running tasks may stop abruptly
* InterruptedException must be handled properly
* Not all tasks stop immediately (depends on interruption handling)

---

## 2. ScheduledExecutorService â°

Used when tasks need to be **delayed or repeated**.

```java
ScheduledExecutorService scheduler =
        Executors.newScheduledThreadPool(1);
```

---

### ðŸ”¹ `schedule()`

**Runs a task once after a delay**

```java
schedule(Runnable command, long delay, TimeUnit unit)
```

```java
scheduler.schedule(
    () -> System.out.println("Run once later"),
    2,
    TimeUnit.SECONDS
);
```

âœ… **Success:**

* Executes once after the given delay

âš ï¸ **Failure Scenarios:**

* If task throws exception â†’ task is lost
* No retry mechanism
* If JVM crashes â†’ task never executes

---

### ðŸ”¹ `scheduleAtFixedRate()`

**Runs a task repeatedly at a fixed rate**

```java
scheduleAtFixedRate(
    Runnable command,
    long initialDelay,
    long period,
    TimeUnit unit
)
```

```java
scheduler.scheduleAtFixedRate(
    () -> System.out.println("Repeats"),
    1,
    3,
    TimeUnit.SECONDS
);
```

ðŸ“Œ **Key Behavior:**

* Time is measured **between task starts**
* Not between task finishes

âœ… **Success:**

* Runs periodically at a fixed rate

âš ï¸ **Failure Scenarios:**

* Exception â†’ future executions stop
* Long-running task + small period â†’ overlap (if multiple threads exist)
* JVM crash â†’ all schedules lost (no persistence)

---

### ðŸ†š Fixed Rate vs Fixed Delay (Interview Tip)

* **Fixed Rate:** strict schedule (may overlap)
* **Fixed Delay:** next execution starts *after previous finishes*

---

## 3. Creating Executors Using Executors Factory ðŸ­

### ðŸ”¹ Fixed Thread Pool

```java
ExecutorService fixedPool =
        Executors.newFixedThreadPool(nThreads);
```

* Fixed number of threads
* Tasks queue up if all threads are busy
* Best for **CPU-bound workloads**

---

### ðŸ”¹ Single Thread Executor

```java
ExecutorService singleExecutor =
        Executors.newSingleThreadExecutor();
```

* Only **one thread**
* Tasks execute sequentially
* Guarantees order of execution

ðŸ“Œ **Why use this instead of Thread?**

* Thread reuse
* Proper lifecycle management
* Exception handling

---

### ðŸ”¹ Cached Thread Pool

```java
ExecutorService cachedPool =
        Executors.newCachedThreadPool();
```

* Creates new threads as needed
* Reuses idle threads
* Best for **short-lived async tasks**

âš ï¸ Risk:

* Can create too many threads if misused

---

### ðŸ”¹ Scheduled Thread Pool

```java
ScheduledExecutorService scheduledPool =
        Executors.newScheduledThreadPool(corePoolSize);
```

* Used for delayed & periodic tasks
* Replaces `Timer` (which is single-threaded & fragile)

---

## 4. Why Multiple Single-Thread Executors? (Advanced Concept ðŸ”¥)

Instead of one pool with many threads:

```java
newFixedThreadPool(5)
```

Sometimes we use **multiple single-thread executors**:

```java
ExecutorService e1 = Executors.newSingleThreadExecutor();
ExecutorService e2 = Executors.newSingleThreadExecutor();
ExecutorService e3 = Executors.newSingleThreadExecutor();
```

### ðŸŽ¯ Reason:

* Each executor has **exactly one thread**
* You can route tasks **to a specific executor**
* Guarantees:

  * Thread affinity
  * Ordering per executor
  * Isolation

ðŸ“Œ **Used in:**

* Caching systems
* Read-your-own-write consistency
* Event processing systems

> â€œI want request A to always go to thread Xâ€
> â†’ SingleThreadExecutor is perfect.

---
