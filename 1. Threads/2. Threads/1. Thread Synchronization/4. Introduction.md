
---

# Why You Shouldn’t Use `synchronized` at Method Level (Always)

---

## 1. The Problem Being Solved

When multiple threads modify a **shared variable**, race conditions occur.

### ❌ Without Synchronization

```java
counter++;
```

This is **not atomic**:

1. Read counter
2. Increment
3. Write back

Two threads can interleave and produce incorrect results.

---

## 2. Method-Level Synchronization (Initial Fix)

### Code

```java
public class Main {
    private static int counter = 0;

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment();
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("Counter value : " + counter);
    }

    private synchronized static void increment() {
        counter++;
    }
}
```

### Output

```
Counter value : 20000
```

✔ **Race condition fixed**

---

## 3. How `synchronized` Works (Monitor Lock Concept)

* Every Java object has an **intrinsic (monitor) lock**
* `synchronized`:

  * **Acquires lock** before entering
  * **Releases lock** on exit
* If lock is held → other threads go to **BLOCKED** state

### Static synchronized method

```java
private synchronized static void increment()
```

Locks on:

```java
Main.class   // Class-level lock
```

---

## 4. Why Method-Level `synchronized` Is Problematic

### ❌ Problem 1: **Coarse-Grained Locking**

* Entire method is locked
* Even non-critical code is blocked
* Reduces concurrency
* Performance bottleneck

---

### ❌ Problem 2: **No Fine-Grained Control**

* You may want to lock:

  * Only 2–3 lines
  * Different parts with different locks
* Method-level sync locks **everything**

---

### ❌ Problem 3: **Inheritance Pitfall**

* If a subclass overrides a synchronized method:

  * It **must explicitly add `synchronized`**
* Otherwise → broken thread safety

---

## 5. Real Issue Demonstration (Two Independent Counters)

### Code Using Method-Level Synchronization

```java
public class Main {

    private static int counter1 = 0;
    private static int counter2 = 0;

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment1();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment2();
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("Counter value 1 : " + counter1);
        System.out.println("Counter value 2 : " + counter2);
    }

    private synchronized static void increment1() {
        counter1++;
    }

    private synchronized static void increment2() {
        counter2++;
    }
}
```

### Output

```
Counter value 1 : 10000
Counter value 2 : 10000
```

✔ Correct output
❌ **Unnecessary blocking**

---

## 6. What’s Wrong Here?

* `increment1()` and `increment2()`:

  * Work on **different variables**
  * Should **not block each other**
* But both methods acquire:

```java
Main.class lock
```

### Result

* Thread-2 waits even though:

  * It doesn’t touch `counter1`
* **False contention**

---

## 7. Correct Approach: Block-Level Synchronization with Custom Locks

### Key Idea

> **Different shared resources → Different locks**

---

### Code Using Custom Locks

```java
public class Main {

    private static int counter1 = 0;
    private static int counter2 = 0;

    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment1();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment2();
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("Counter value 1 : " + counter1);
        System.out.println("Counter value 2 : " + counter2);
    }

    private static void increment1() {
        synchronized (lock1) {
            counter1++;
        }
    }

    private static void increment2() {
        synchronized (lock2) {
            counter2++;
        }
    }
}
```

### Output

```
Counter value 1 : 10000
Counter value 2 : 10000
```

---

## 8. Why This Is Better

✔ Fine-grained locking
✔ Better concurrency
✔ No unnecessary blocking
✔ Clear ownership of shared resources

Each critical section has **its own lock**.

---

## 9. When Method-Level `synchronized` Is OK

✔ Entire method is critical
✔ Very small method
✔ Simple use-case
✔ No scalability concerns

---

## 10. Best Practices Summary

| Scenario                  | Recommendation                                   |
| ------------------------- | ------------------------------------------------ |
| Single shared resource    | Method-level sync acceptable                     |
| Multiple shared resources | Block-level sync                                 |
| High contention           | Custom locks                                     |
| Advanced control          | `java.util.concurrent` (`Lock`, `ReentrantLock`) |

---

## Final Takeaway

> **Method-level `synchronized` works, but it often over-locks.
> Block-level synchronization gives you precision, performance, and scalability.**

---