---

# **ðŸ“Œ Sequential Processing vs Parallel Processing (Thread Class)**

---

# **1. Sequential Processing**

### **Concept**

* In sequential processing, tasks execute **one after another**.
* Only **one thread** (main thread) is running.
* Next task starts **only after the previous one finishes**.

---

## **ðŸ“Œ Complete Code â€” Sequential Processing**

### **Worker1.java**

```java
public class Worker1
{
    public void executeWork() throws InterruptedException
    {
        for(int i = 0; i < 10; i++)
        {
            Thread.sleep(100);
            System.out.println("Worker 1 is executing task " + i);
        }
    }
}
```

### **Worker2.java**

```java
public class Worker2
{
    public void executeWork()
    {
        for(int i = 0; i < 10; i++)
        {
            try
            {
                Thread.sleep(100);
            }
            catch (InterruptedException e)
            {
                System.out.println(e);
            }

            System.out.println("Worker 2 is executing task " + i);
        }
    }
}
```

### **Main.java (Sequential)**

```java
public class Main
{
    public static void main(String[] args)
    {
        Worker1 worker1 = new Worker1();
        Worker2 worker2 = new Worker2();

        try
        {
            worker1.executeWork();  // Runs completely first
        }
        catch (InterruptedException e)
        {
            System.out.println(e);
        }

        worker2.executeWork();      // Runs after worker1 finishes
    }
}
```

---

### **Characteristics**

* Executes tasks in **ordered sequence**.
* Slower because tasks cannot overlap.
* Only **one CPU path** is used at a time.
* Good for simple scenarios but **not optimal** for large workloads.

---

## **Output**

```
Worker 1 is executing task 0
...
Worker 1 is executing task 9
Worker 2 is executing task 0
...
Worker 2 is executing task 9
```

---

# **2. Parallel Processing (Using Thread Class)**

### **Concept**

* Multiple threads execute **simultaneously**.
* Each worker class extends `Thread` and overrides `run()`.
* Calling `start()` creates a **new thread of execution**.
* Each worker runs in its **own thread**.
* Use `start()` (not `run()`) to start threads in parallel.
* JVM thread scheduler decides execution order.

---

## **Key Methods**

### **start()**

* Creates a **new thread** and calls `run()` internally.
* Executes code **in parallel** with other threads.

### **run()**

* Contains the task that the thread executes.
* If called directly, it will NOT create a new thread.

---

## **ðŸ“Œ Complete Code â€” Parallel Processing**

### **ParallelWorker1.java**

```java
public class ParallelWorker1 extends Thread
{
    @Override
    public void run()
    {
        for(int i = 0; i < 10; i++)
        {
            try 
            {
                Thread.sleep(100);
            } 
            catch (InterruptedException e) 
            {
                throw new RuntimeException(e);
            }

            System.out.println("Worker 1 is executing task " + i);
        }
    }
}
```

### **ParallelWorker2.java**

```java
public class ParallelWorker2 extends Thread
{
    @Override
    public void run()
    {
        for(int i = 0; i < 10; i++)
        {
            try
            {
                Thread.sleep(100);
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }

            System.out.println("Worker 2 is executing task " + i);
        }
    }
}
```

### **Main.java (Parallel)**

```java
public class Main
{
    public static void main(String[] args)
    {
        ParallelWorker1 worker1 = new ParallelWorker1();
        ParallelWorker2 worker2 = new ParallelWorker2();

        worker1.start();  // Starts thread 1
        worker2.start();  // Starts thread 2
    }
}
```

---


## **Output**

* Interleaving / mixed output because both threads run in parallel:

```
Worker 1 is executing task 0
Worker 2 is executing task 0
Worker 1 is executing task 1
Worker 2 is executing task 1
...
```

Order is **not guaranteed**, depends on JVM thread scheduler.

---

# **3. Differences â€” Sequential vs Parallel Processing**

| Feature        | Sequential         | Parallel (Multithreading)            |
| -------------- | ------------------ | ------------------------------------ |
| Execution      | One task at a time | Multiple tasks at same time          |
| Method used    | Normal method calls| `start()` â†’ creates new thread       |
| Threads        | Only main thread   | Multiple threads                     |
| Speed          | Slower             | Faster (if CPU has multiple cores)   |
| Resource usage | Underutilizes CPU  | Better CPU utilization               |
| Output order   | Predictable        | Unpredictable (depends on scheduler) |

---

# **4. Why Parallel Processing Helps**

* On multi-core CPUs, threads run on **different cores simultaneously**.
* Even on single-core CPUs, time slicing makes it feel parallel.

---





